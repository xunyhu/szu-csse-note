<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第一章 C++简介 | R</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://xunyhu.github.io/image/favicon.ico">
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.1a8e0fbc.css" as="style"><link rel="preload" href="/assets/js/app.3b4388ed.js" as="script"><link rel="preload" href="/assets/js/2.10b3e4ea.js" as="script"><link rel="preload" href="/assets/js/30.5d380278.js" as="script"><link rel="prefetch" href="/assets/js/10.d5aef7bd.js"><link rel="prefetch" href="/assets/js/11.bb90b8c9.js"><link rel="prefetch" href="/assets/js/12.6cfcf9c3.js"><link rel="prefetch" href="/assets/js/13.2d9ed724.js"><link rel="prefetch" href="/assets/js/14.9c217a9e.js"><link rel="prefetch" href="/assets/js/15.70a3c708.js"><link rel="prefetch" href="/assets/js/16.be337503.js"><link rel="prefetch" href="/assets/js/17.88c2ce55.js"><link rel="prefetch" href="/assets/js/18.4a06556f.js"><link rel="prefetch" href="/assets/js/19.81a2041b.js"><link rel="prefetch" href="/assets/js/20.be789981.js"><link rel="prefetch" href="/assets/js/21.825d0143.js"><link rel="prefetch" href="/assets/js/22.e6efa1d3.js"><link rel="prefetch" href="/assets/js/23.dd7746f1.js"><link rel="prefetch" href="/assets/js/24.85415efa.js"><link rel="prefetch" href="/assets/js/25.21ab202f.js"><link rel="prefetch" href="/assets/js/26.de7afa6a.js"><link rel="prefetch" href="/assets/js/27.a9f64598.js"><link rel="prefetch" href="/assets/js/28.3fcaa6f2.js"><link rel="prefetch" href="/assets/js/29.35702d9b.js"><link rel="prefetch" href="/assets/js/3.d3d6240c.js"><link rel="prefetch" href="/assets/js/31.458edbca.js"><link rel="prefetch" href="/assets/js/32.cbce3cde.js"><link rel="prefetch" href="/assets/js/33.b9019a77.js"><link rel="prefetch" href="/assets/js/34.17cfd457.js"><link rel="prefetch" href="/assets/js/35.7fb8274c.js"><link rel="prefetch" href="/assets/js/36.2e3a3866.js"><link rel="prefetch" href="/assets/js/37.2c161539.js"><link rel="prefetch" href="/assets/js/38.38a8b365.js"><link rel="prefetch" href="/assets/js/39.3be76881.js"><link rel="prefetch" href="/assets/js/4.0f570684.js"><link rel="prefetch" href="/assets/js/40.7dc697fb.js"><link rel="prefetch" href="/assets/js/41.a5ccdda3.js"><link rel="prefetch" href="/assets/js/42.ca5b907b.js"><link rel="prefetch" href="/assets/js/43.23621d4f.js"><link rel="prefetch" href="/assets/js/44.a6f2fefe.js"><link rel="prefetch" href="/assets/js/45.2dc33749.js"><link rel="prefetch" href="/assets/js/46.c7101c66.js"><link rel="prefetch" href="/assets/js/47.d24c7011.js"><link rel="prefetch" href="/assets/js/48.b84c555f.js"><link rel="prefetch" href="/assets/js/49.fa4326aa.js"><link rel="prefetch" href="/assets/js/5.734ae6af.js"><link rel="prefetch" href="/assets/js/50.290b69d5.js"><link rel="prefetch" href="/assets/js/51.1d05fccf.js"><link rel="prefetch" href="/assets/js/52.9f9563ae.js"><link rel="prefetch" href="/assets/js/53.31b84813.js"><link rel="prefetch" href="/assets/js/54.6ea1177f.js"><link rel="prefetch" href="/assets/js/55.4b34c753.js"><link rel="prefetch" href="/assets/js/56.1af848c0.js"><link rel="prefetch" href="/assets/js/57.7f5ccefc.js"><link rel="prefetch" href="/assets/js/58.0b7e93b1.js"><link rel="prefetch" href="/assets/js/59.1b598669.js"><link rel="prefetch" href="/assets/js/6.814edb6d.js"><link rel="prefetch" href="/assets/js/60.3c263ff3.js"><link rel="prefetch" href="/assets/js/61.dbab0bee.js"><link rel="prefetch" href="/assets/js/62.fc9ffb8c.js"><link rel="prefetch" href="/assets/js/7.3852f5ef.js"><link rel="prefetch" href="/assets/js/8.a3583ec9.js"><link rel="prefetch" href="/assets/js/9.d6d7619e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a8e0fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">R</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="深大自考" class="dropdown-title"><span class="title">深大自考</span> <span class="arrow down"></span></button> <button type="button" aria-label="深大自考" class="mobile-dropdown-title"><span class="title">深大自考</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szu/pest3/" class="nav-link">
  PEST-3
</a></li><li class="dropdown-item"><!----> <a href="/szu/c++/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  C++程序设计
</a></li><li class="dropdown-item"><!----> <a href="/szu/structure/" class="nav-link">
  数据结构导论
</a></li><li class="dropdown-item"><!----> <a href="/szu/os/" class="nav-link">
  操作系统概论
</a></li><li class="dropdown-item"><!----> <a href="/szu/software/" class="nav-link">
  软件开发工具
</a></li><li class="dropdown-item"><!----> <a href="/szu/database/" class="nav-link">
  数据库系统原理
</a></li><li class="dropdown-item"><!----> <a href="/szu/network/" class="nav-link">
  计算机网络原理
</a></li><li class="dropdown-item"><!----> <a href="/szu/history/" class="nav-link">
  中国近现代史纲要
</a></li><li class="dropdown-item"><!----> <a href="/szu/marx/" class="nav-link">
  马克思主义基本原理概论
</a></li><li class="dropdown-item"><!----> <a href="/szu/business/" class="nav-link">
  网络经济与企业管理
</a></li></ul></div></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="深大自考" class="dropdown-title"><span class="title">深大自考</span> <span class="arrow down"></span></button> <button type="button" aria-label="深大自考" class="mobile-dropdown-title"><span class="title">深大自考</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szu/pest3/" class="nav-link">
  PEST-3
</a></li><li class="dropdown-item"><!----> <a href="/szu/c++/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  C++程序设计
</a></li><li class="dropdown-item"><!----> <a href="/szu/structure/" class="nav-link">
  数据结构导论
</a></li><li class="dropdown-item"><!----> <a href="/szu/os/" class="nav-link">
  操作系统概论
</a></li><li class="dropdown-item"><!----> <a href="/szu/software/" class="nav-link">
  软件开发工具
</a></li><li class="dropdown-item"><!----> <a href="/szu/database/" class="nav-link">
  数据库系统原理
</a></li><li class="dropdown-item"><!----> <a href="/szu/network/" class="nav-link">
  计算机网络原理
</a></li><li class="dropdown-item"><!----> <a href="/szu/history/" class="nav-link">
  中国近现代史纲要
</a></li><li class="dropdown-item"><!----> <a href="/szu/marx/" class="nav-link">
  马克思主义基本原理概论
</a></li><li class="dropdown-item"><!----> <a href="/szu/business/" class="nav-link">
  网络经济与企业管理
</a></li></ul></div></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>《C++程序设计》</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/szu/c++/" aria-current="page" class="active sidebar-link">章节简要笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/szu/c++/#第一章-c-简介" class="sidebar-link">第一章 C++简介</a></li><li class="sidebar-sub-header"><a href="/szu/c++/#第二章-面向对象的基本概念" class="sidebar-link">第二章 面向对象的基本概念</a></li><li class="sidebar-sub-header"><a href="/szu/c++/#第三章-类和对象进阶" class="sidebar-link">第三章 类和对象进阶</a></li><li class="sidebar-sub-header"><a href="/szu/c++/#第七章-输入-输出流" class="sidebar-link">第七章 输入/输出流</a></li><li class="sidebar-sub-header"><a href="/szu/c++/#第八章-文件操作" class="sidebar-link">第八章 文件操作</a></li><li class="sidebar-sub-header"><a href="/szu/c++/#第九章-函数模板与类模板" class="sidebar-link">第九章 函数模板与类模板</a></li></ul></li><li><a href="/szu/c++/introduce.html" class="sidebar-link">课程简介</a></li><li><a href="/szu/c++/fill-blank.html" class="sidebar-link">课后填空题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="第一章-c-简介"><a href="#第一章-c-简介" class="header-anchor">#</a> 第一章 C++简介</h2> <ol><li>C++语言的发展简史
<ul><li>随着 20 世纪 40 年代计算机的面世，计算机程序设计语言也应用而生。通常根据是否可以直接操作计算机底层硬件，将程序设计语言分为低级语言、中级语言和高级语言。
<ul><li>机器语言和汇编语言属于低级语言一类，因为他们能够直接操作计算机的寄存器和内存。</li> <li>汇编语言使用能够代表指令的助记符来编写程序，可以看作是符号化了的机器语言。</li> <li>高级语言是面向用户的语言，很多语言在形式上接近算术语言和自然语言，程序员编写方便。使用高级语言编写的程序易读且通用性强，但大部分不能直接与硬件打交道，也不能直接在计算机上运行，需要系统软件的支持，如需要编译程序及链接程序将高级语言编译链接为机器指令后才能运行。</li></ul></li> <li>C++标准发展： C++03、C++11、C++14 和 C++17</li></ul></li> <li>C++语言的特点
<ul><li>1.基本的输入输出</li> <li>2.头文件和命名空间
<ul><li><code>using namespage std</code>表示使用命名空间 std</li></ul></li> <li>3.强制类型转换运算符
<ul><li><code>staic_cast&lt;类型名&gt;(表达式)</code> 用于将一种数据类型转化为另一个数据类型</li> <li><code>const_cast&lt;类型名&gt;(表达式)</code> 用于去除指针和引用的常量性，但不能去除变量的常量性</li></ul></li> <li>4.函数参数的默认值</li> <li>5.引用和函数参数的传递
<ul><li>1.引用定义<code>类型名 &amp;引用名 = 同类型的某变量名</code></li> <li>2.引用在函数中的作用
<ul><li>引用作为函数返回值：<code>数据类型 &amp; 函数名(参数列表)</code></li> <li>函数的返回值还可以是指针：<code>类型标识符 * 函数名(参数列表)</code></li></ul></li></ul></li> <li>6.const 与指针共同使用</li> <li>7.内联函数<div class="language-cpp extra-class"><pre class="language-cpp"><code>   <span class="token keyword">inline</span> 返回值类型 函数名<span class="token punctuation">(</span>形参表<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      函数体
   <span class="token punctuation">}</span>
</code></pre></div></li> <li>8.函数重载</li> <li>9.指针和内存动态分配
<ul><li><code>指针指向一个地址</code></li></ul></li> <li>10.用 string 对象处理字符串</li></ul></li> <li>C++语言的程序结构
<ul><li>C++程序以.cpp 为文件扩展名。程序中必须要有一个主函数 main(),这是程序执行的总入口，程序从主函数的开始处执行，按照其控制结构，一直执行到结束。</li> <li>程序结束的两种情形：1.在主函数遇到 return；2.执行到主函数最后面的<code>}</code>。</li> <li>注释：单行注释<code>//</code>;多行注释<code>/* */</code></li></ul></li></ol> <h2 id="第二章-面向对象的基本概念"><a href="#第二章-面向对象的基本概念" class="header-anchor">#</a> 第二章 面向对象的基本概念</h2> <ol><li>结构化程序设计
<ul><li>在面对对象之前，软件界广泛流行的设计方法之一就是结构化设计，也称面向过程的设计方法。</li> <li>基本上程序都有顺序、选择、循环 3 中基本控制过程。有一个著名的公式体现了结构化程序设计的思想：<code>数据结构 + 算法 = 程序</code></li> <li>缺点：函数复用十分困难；可能会有数目众多的全局变量和全局函数，模块间耦合度高，难以维护。</li></ul></li> <li>面向对象程序设计的概念和特点
<ul><li>面向对象方法是 20 世纪 90 年代以来软件开放的主流，它继承了结构化程序设计方法的优点，又改善了结构化程序的不足。</li> <li>面向对象 4 个基本特点：“抽象”、“封装”、“继承”、“多态”。
<ul><li>将同一类事物的共同特点概括出来，这个过程就叫做“抽象”。<code>类是对现实世界中客观事物的抽象</code>。</li> <li>在完成抽象后(即定义为一个类之后)，再定义类的对象，每个对象包含了这个类规定的若干私有成员、公有成员、保护成员。这个过程就叫“封装”。
<ul><li>封装体现的特点是将对象的属性及实现细节隐藏起来，只给出如何使用的信息。有了封装机制，对象内部的实现细节受到保护，公开的信息成为与外界交互的<code>接口</code>。<code>对象是类的实例</code>。</li></ul></li> <li>“继承”就是在编写一个“新”类的时候，以现有的类为基础，使得新类从现有的类“派生”出来，从而到达代码扩充和代码复用目的。</li> <li>“多态”是指不同种类的对象具有名称相同的行为，而具体行为的实现方式却有所不同。多态性源于一个希腊单词，意思是“许多形态”。
<ul><li>继承性与多态性的组合，可以轻易地生成一系列虽然类似但独一无二的对象。由于继承，这些对象有共同特性；由于多态，不同的对象可以有不同的独特的表现方式。</li></ul></li></ul></li></ul></li> <li>类的初步知识
<ul><li>类的定义格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 类名
<span class="token punctuation">{</span>
    访问范围说明符：
        成员变量 <span class="token number">1</span>
        成员变量 <span class="token number">2</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        成员函数声明<span class="token number">1</span>
        成员函数声明<span class="token number">2</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    访问范围说明符<span class="token operator">:</span>
        更多成员变量
        更多成员函数声明
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>类的成员函数定义格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>返回值类型 类名<span class="token double-colon punctuation">::</span>成员函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   函数体
<span class="token punctuation">}</span>
</code></pre></div></li> <li>类的示例程序剖析
<ul><li>1.程序结构
<ul><li>一个完整的 C++程序包括几个部分：1.主函数；2.用户定义的任意多个类及全局函数；3.全局说明；4.注释；5.头文件(.h 文件)；</li> <li>函数的非内联函数不能放在头文件中</li></ul></li> <li>2.成员变量与成员函数的定义</li> <li>3.创建类对象的基本形式</li></ul></li> <li>访问对象的成员
<ul><li>1.使用对象访问成员变量与调用成员函数</li> <li>2.使用指针访问对象成员
<ul><li>格式<code>指针-&gt;成员名</code></li></ul></li> <li>3.使用引用访问对象的成员</li> <li>访问示例</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//1、使用对象访问 (点运算符)</span>
A<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
<span class="token comment">//2. 使用指针访问（箭头运算符）</span>
A a1<span class="token punctuation">;</span>
A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a1<span class="token punctuation">;</span>
p <span class="token operator">-&gt;</span> a1
<span class="token comment">//3. 使用引用访问</span>
A <span class="token operator">&amp;</span>s <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">//a1的别名s</span>
</code></pre></div></li> <li>类成员的可访问范围
<ul><li><code>public、private、protected</code></li> <li>public 修饰的成员可以在本程序的任何地方被访问</li> <li>private 修饰的成员<code>仅仅能在本类中访问</code> <ul><li>使用 private 修饰符可以实现“隐藏”的作用，避免对对象的不正常操作。</li></ul></li> <li>protected 修饰的成员<code>在本类及子类中可以被访问</code></li></ul></li> <li>标识符的作用域与可见性
<ul><li>标识符
<ul><li>标识符：如类名、函数名、变量名、常量名和枚举类型的取值等等</li> <li>标识符的作用域：1.函数原型作用域、2.局部作用域(块作用域)、3.类作用域、4.命名空间作用域</li></ul></li> <li>可见性原则
<ul><li>1.标识符要声明在前，引用在后</li> <li>2.同一个作用域中，不能声明同名的标识符。没有包含关系的作用域中命名同名标识符，互不影响。</li> <li>3.如果存在多个具有包含关系的作用域，声明的同名标识符，内层标识符会隐藏外层同名标识符。</li></ul></li></ul></li></ol> <h2 id="第三章-类和对象进阶"><a href="#第三章-类和对象进阶" class="header-anchor">#</a> 第三章 类和对象进阶</h2> <ol><li><p>构造函数</p> <ul><li>1.构造函数的作用：<code>给对象初始化的时候赋值</code></li> <li>2.构造函数的定义（3 种形式）</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>   <span class="token comment">//形式1</span>
   类名<span class="token double-colon punctuation">::</span>类名<span class="token punctuation">(</span>形参<span class="token number">1</span>、、、形参n<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x1</span><span class="token punctuation">(</span>形参<span class="token number">1</span><span class="token punctuation">)</span>、、、<span class="token function">xn</span><span class="token punctuation">(</span>形参n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

   <span class="token comment">//形式2</span>
   类名<span class="token double-colon punctuation">::</span>类名<span class="token punctuation">(</span>形参<span class="token number">1</span>、、、形参n<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      x1 <span class="token operator">=</span> 形参<span class="token number">1</span><span class="token punctuation">;</span>
      、、、
      xn <span class="token operator">=</span> 形参n；
   <span class="token punctuation">}</span>

   <span class="token comment">//形式3</span>
    类名<span class="token double-colon punctuation">::</span>类名<span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      x1 <span class="token operator">=</span> 初始值<span class="token number">1</span><span class="token punctuation">;</span>
      、、、
      xn <span class="token operator">=</span> 初始值n<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>3.构造函数使用
<ul><li>构造函数由系统自动调用，不由程序员控制。因为对象需要占据内存空间，生成对象时，为对象分配的这段内存空间的初始化由构造函数完成。</li></ul></li> <li>4.复制构造函数与类型转换构造函数</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 类名
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    类名<span class="token punctuation">(</span>类名 <span class="token operator">&amp;</span> 对象名<span class="token punctuation">)</span> <span class="token comment">//复制构造函数</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

类名<span class="token double-colon punctuation">::</span>类名<span class="token punctuation">(</span>类名 <span class="token operator">&amp;</span> 对象名<span class="token punctuation">)</span> <span class="token comment">//复制构造函数的实现</span>
<span class="token punctuation">{</span>
    函数体
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>析构函数</p> <ul><li>与构造函数一样，析构函数也是成员函数的一种，它的名称与类名相同但是要在类名前面加<code>~</code>字符。</li> <li>构造函数没有参数、没有返回值。一个类有且仅有一个析构函数。</li> <li>使用<code>new运算符</code>号创建的对象，则要在析构函数中使用<code>delete</code>释放掉这部分占用的空间</li></ul></li> <li><p>类的静态成员 1.静态变量</p> <ul><li>使用<code>static</code>修饰 2.类的静态成员</li> <li>赋值格式：<code>类型 类名::静态成员变量 = 初值；</code></li> <li>取值：<code>类名::静态成员名</code>或<code>对象名.静态成员名</code>或<code>对象指针-&gt;静态成员名</code></li> <li>类的静态成员函数没有 this 指针</li></ul></li> <li><p>变量及对象的生存期和作用域</p></li> <li><p>常量成员和常引用成员</p> <ul><li>定义常量对象的格式：<code>const 数据类型 常量名 = 表达式</code></li> <li>定义常量函数的格式：<code>类型说明符 函数名(参数表) const</code></li> <li>常量对象只能调用常量函数</li></ul></li> <li><p>成员对象和封闭类</p> <ul><li>一个类的成员变量如果是另一个类的对象，则该成员变量称为“成员对象”，包含成员对象的类叫做“封闭类”。</li> <li><strong>封闭类的复制构造函数</strong></li></ul></li> <li><p>友元</p> <ul><li>友元机制是对一些类外的函数打开的一个特殊通道，授权它们能够访问本类的私有成员变量。使用<code>friend</code>标识</li> <li>将类 A 的成员函数说明为本类的友元函数的格式：<code>friend 返回值类型 类A::类A的成员函数名(参数表);</code></li> <li>友元类：<code>friend class 类名</code></li></ul></li> <li><p>this 指针</p> <ul><li>C++语言规定，当调用一个成员函数时，系统自动向它传递一个隐含的参数。该参数是一个指向调用该函数的对象的指针，称为<code>this指针</code>。</li></ul></li></ol> <h3 id="第四章-运算符重载"><a href="#第四章-运算符重载" class="header-anchor">#</a> 第四章 运算符重载</h3> <ol><li>运算符重载的概念
<ul><li>运算符重载格式：</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>     返回值类型  <span class="token keyword">operator</span> 运算符<span class="token punctuation">(</span>形参表<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         函数体
     <span class="token punctuation">}</span>
</code></pre></div><ul><li>有两个运算符是系统默认提供的重载运算符，即赋值=和地址运算符&amp;</li> <li>运算符重载的规则
<ul><li>1.重载后应符合原有的用法习惯</li> <li>2.不能改变原有的语义、优先级、结合性</li> <li>3.不能改变运算符操作数的个数及语法结构</li> <li>4.不能创建新的运算符</li> <li>5.重载运算符“()”“[]”“-&gt;”或者赋值运算符“=”时，只能重载为成员函数，不能重载为全局函数</li> <li>6.不能改变运算符用于基本数据类型对象的含义</li></ul></li></ul></li> <li>重载赋值运算符</li> <li>重载流插入运算符和流提取运算符</li> <li>重载强制类型转换运算符</li> <li>重载自增、自减运算符
<ul><li>自增&quot;++&quot;和自减&quot;--&quot;都可以被重载，但是它们有前置和后置之分。“++obj”返回值是被修改后的值，“obj++”返回值是被修改前的值。</li> <li>为了解决上诉问题，C++规定允许增加了无用int类型形参的版本处理前后置的问题，调用多出一个参数的代表后置。</li> <li>格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>   Demo <span class="token operator">&amp;</span> Demo<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      n<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//后置</span>
   Demo Demo<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      Demo <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      n<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre></div></li></ol> <h3 id="第五章-类的继承与派生"><a href="#第五章-类的继承与派生" class="header-anchor">#</a> 第五章 类的继承与派生</h3> <ol><li>类的继承与类的派生<br>
在程序设计方法中，人们追求代码复用（提高软件开发效率的重要手段），将继承和派生用于程序设计方法中，从而有了面向对象程序设计的重要特点。C++对代码复用有很强的支持，“继承”就是支持代码复用的机制之一。<br>
继承与派生有相同的含义，不同的角度。继承对应于自下而上的过程，派生对应于自上而下的过程。从基类的角度看，是派生了子类。从子类的角度看，是继承于基类。<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 派生类名 ：继承方式说明符 基类名
<span class="token punctuation">{</span>
    类体
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>多重继承<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 派生类名 ：继承方式说明符 基类名<span class="token number">1</span><span class="token punctuation">,</span> 继承方式说明符 基类名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> 继承方式说明符 基类名n
<span class="token punctuation">{</span>
    类体
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>访问控制</li> <li>派生类的构造函数和析构函数</li> <li>类之间的关系
<ul><li>继承关系和组合关系</li> <li>封闭类：如果一个类的成员变量是另一类的对象，则为封闭类。</li> <li>互包含关系的类</li></ul></li> <li>多层次的派生</li> <li>基类与派生类指针的互相转换</li></ol> <h3 id="第六章-多态与虚函数"><a href="#第六章-多态与虚函数" class="header-anchor">#</a> 第六章 多态与虚函数</h3> <ol><li>多态的基本概念
<ul><li>1.多态
<ul><li>面向对象设计语言有封装、继承、多态 3 种机制。</li> <li>多态分文编译时多态和运行时多态。编译时多态是指函数的重载，对重载函数的调用，在编译时就可以根据实参确定应该调用哪个函数。运行时多态则和继承、虚函数等概念有关。</li> <li>多态体现<code>一样的语句，不一样的执行效果</code></li></ul></li> <li>2.虚函数
<ul><li>格式：<code>virtual 函数返回值类型 函数名(形参表)</code></li> <li>有几点需要注意：
<ul><li>1.虚函数一般不声明为内联函数，虽然不会报错</li> <li>2.派生类重写基类虚函数，要求函数名、参数列表、返回值类型要完全相同</li> <li>3.只有类的非静态成员才能定义为虚函数，静态成员函数和友元函数不能定义为虚函数</li> <li>4.如果在类体外定义虚函数，只需在声明函数时添加<code>virtual</code>关键字，定义时不用加</li> <li>5.<code>构造函数不能定义为虚函数</code>。最好也不要将<code>operator=</code>定义为虚函数</li> <li>6.不要在构造函数和析构函数中调用虚函数。此时对象是不完整的，可能出现未定义的行为。</li> <li>7.最好将基类的析构函数声明为虚函数。</li></ul></li> <li>常见不能声明为虚函数的有：全局函数（非成员函数）、静态成员函数、内联成员函数、构造函数和友元函数。</li></ul></li> <li>3.通过基类指针实现多态</li> <li>4.通过基类引用实现多态</li> <li><strong>5.多态的实现原理</strong> <ul><li>多态的关键在于通过基类指针或引用调用一个虚函数时，编译阶段不能确定到底调用的是基类还是派生类的函数，运行时才能确定。</li></ul></li></ul></li> <li>多态实例</li> <li>多态的使用</li> <li>虚析构函数
<ul><li>格式：<code>virtual ~类名();</code></li> <li>使用需析构函数的目的是为了在对象消亡是实现多态。可以用来保证使用基类类型的指针对不同对象进行清理过程，防止内存泄露。</li></ul></li> <li>纯虚函数和抽象类
<ul><li>纯虚函数
<ul><li>格式：<code>virtual 函数类型 函数名(参数表)=0;</code></li></ul></li> <li>抽象类
<ul><li>包含纯虚函数的类称为抽象类。</li> <li>因为抽象类中有尚未完成的函数定义，所以不能实例化对象。抽象类的派生类中，如果没有给出全部纯虚函数的定义，则依然是抽象类。</li> <li>不能实例化对象，但是可以定义抽象类的指针和引用。</li></ul></li></ul></li></ol> <h2 id="第七章-输入-输出流"><a href="#第七章-输入-输出流" class="header-anchor">#</a> 第七章 输入/输出流</h2> <ol><li>流类简介</li> <li>标准流对象
<ul><li>c++在iostream中预定义了4个标准流对象，分别是cin、cout、cerr、clog</li></ul></li> <li>控制 I/O 格式</li> <li>调用 cout 的成员函数
<ul><li>1.设置和返回输出宽度<code>int width(int nw)</code></li></ul></li> <li>调用 cin 的成员函数</li></ol> <h2 id="第八章-文件操作"><a href="#第八章-文件操作" class="header-anchor">#</a> 第八章 文件操作</h2> <ol><li>文件基本概念和文件流类
<ul><li>文件的概念</li> <li>C++文件流类
<ul><li><code>ifsream</code>用于从文件读取数据</li> <li><code>ofsream</code>用于从文件写入数据</li> <li><code>fstream</code>读写都可以</li> <li>3 个步骤：open 文件——操作文件——close 文件</li></ul></li></ul></li> <li>打开和关闭文件
<ul><li>打开文件的方式有两种
<ul><li>1.<code>流类名 对象名； 对象名.open(文件名, 模式)</code></li> <li>2.<code>流类名 对象名(文件名, 模式)</code></li> <li>流类是指 C++流类库定义的文件流类</li> <li><a href="https://www.cnblogs.com/azraelly/archive/2012/04/14/2446914.html" target="_blank" rel="noopener noreferrer">C++文件操作详解（ifstream、ofstream、fstream）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><code>判断文件打开是否成功</code>，可以用“对象名”的值是否为 true 进行判断</li></ul></li> <li>关闭文件
<ul><li>使用 fstream 的成员函数<code>close()</code>关闭文件</li></ul></li></ul></li> <li>文件读写操作
<ul><li>读写文本文件</li> <li>读写二进制文件
<ul><li>用 ostream::write()成员函数写文件</li> <li>用 istream::read()成员函数写文件</li> <li>用 ostream::gcount()成员函数得到读取字节数</li></ul></li> <li>使用成员函数 put()和 get()读写文件</li> <li>文本文件与二进制文件的异同</li></ul></li> <li>随机访问文件</li></ol> <h2 id="第九章-函数模板与类模板"><a href="#第九章-函数模板与类模板" class="header-anchor">#</a> 第九章 函数模板与类模板</h2> <ul><li>泛型程序设计：在于能够减少重复代码的编写</li></ul> <ol><li>函数模板
<ul><li>把处理不同类型的公共逻辑抽象成函数，就得到了函数模板。调用函数模板时，类似于一般函数的调用，但需要给出具体的实参。</li> <li>定义格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>   <span class="token keyword">template</span><span class="token operator">&lt;</span>模板参数表<span class="token operator">&gt;</span>
   返回类型名  函数模板名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      函数体
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>模板参数表的构成“类型 参数名...”
<ul><li>可以为 class 标识符</li> <li>类型说明符标识符</li></ul></li> <li>函数模板与函数的本质区别
<ul><li>1.函数模板本身在编译时不会生成任何目标代码</li> <li>2.被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，而不能像普通函数那样只将声明放在头文件中</li> <li>3.函数指针也只能指向模板的实例，而不能指向模板本身</li></ul></li> <li>显示实例化函数模板的一般格式：<code>模板名 &lt;实际类型参数1，...&gt;</code></li></ul></li> <li>类模板
<ul><li>声明类模板的格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>   <span class="token keyword">template</span><span class="token operator">&lt;</span>模板参数表<span class="token operator">&gt;</span>
   <span class="token keyword">class</span> 类模板名
   <span class="token punctuation">{</span>
      类体
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>类模板的成员函数可以在类体内进行说明，也可以在类体外说明。在类体内定义，则自动生成为内联函数。</li> <li>在类体外定义格式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>  <span class="token keyword">template</span><span class="token operator">&lt;</span>模板参数表<span class="token operator">&gt;</span>
  返回类型名 类模板名<span class="token operator">&lt;</span>模板参数标识符表<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>成员函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
     函数体
  <span class="token punctuation">}</span>
</code></pre></div><ul><li>类模板声明本身并不是一个类，它说明了类的一个家族。不能使用类模板来直接生成对象，因为类型参数是不确定的，模板要实例化后，才可以创建对象。格式如下
<ul><li><code>类模板名 &lt;模板参数表&gt; 对象名1，...对象名n;</code> 或者<code>类模板名 &lt;模板参数表&gt; 对象名1(构造参数实参)，...对象名n(构造参数实参);</code></li></ul></li></ul></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/szu/c++/introduce.html">
        课程简介
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3b4388ed.js" defer></script><script src="/assets/js/2.10b3e4ea.js" defer></script><script src="/assets/js/30.5d380278.js" defer></script>
  </body>
</html>
