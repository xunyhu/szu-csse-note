## 第一章 
1. 在C++程序中，用来从键盘输入值的标准输入流对象是`cin`;
2. 指示编译器将一个源文件嵌入到带该指令的源文件中的指令是`#include`;
3. 函数指针的默认值不允许是`局部变量`;
4. 将指向对象的指针作为函数参数，形参是对象指针，则实参是对象的`地址值`;
5. 定义整形变量oneInt的引用bname的语句是`int &bname = oneInt`;
6. 在C++语言中，如果调用函数时需要改变实参或者返回多个值，传参数时应该采取`传引用或地址`方式
7. 用来声明内联函数的关键字是`inline`
8. 动态申请含20个元素的整型数组A的语句是`int * A = new int[20]`;
9. 使用重载函数编写程序的目的是`使用相同的函数名调用功能相似的函数`;
10. 使用new运算符动态分配的内存，释放时使用的运算符是`delete`；
11. 设在程序中定义了类Point，并使用语句Point *ptr = new Point[2],申请了一个Point对象数组，则释放ptr指向的动态数组对象的语句是：`delete []ptr`;
12. 求string对象s1从下标2开始，一直到串尾的子串，并赋值给string变量s5的语句是:`string s5 = s1.substr(2, s1.length())`;

## 第二章 面向对象
1. 一个项目中只能有一个函数是`main函数`;
2. 类中成员按访问权限，包括：`private, protected, public`;
3. 对象传递的消息一般由3部分组成：`接收对象名`、`调用操作名`和`形参`;
4. 已知有如下的类定义：
    ```cpp
    class A
    {
    public:
        int m;
        int *p = &m;
    };
    ```
    A1是类A的对象。如果要通过指针p给变量m赋值10，相应的语句是：`*A1.p = 10`;
5. 类C中不可以定义类C的`成员变量`;
6. 类C中可以定义类C的`指针或引用`;
7. 已知有如下的类定义：
    ```cpp
    class X
    {
        int a;
        void fun1();
    public:
        void fun2();
    };
    ```
    则在类外使用对象objX能够访问的成员是`fun2()`

## 第三章 类和对象进阶
1. 定义类时，如果一个构造函数没有编写，则编译器自动生成默认（无参）构造函数和`赋值构造函数`;
2. 复制构造函数的形参个数是`一个`;
3. 复制构造函数的形参是`本类对象的引用`;
4. 说明一个类的对象时，系统自动调用`构造函数`;
5. 程序中撤销一个类对象时，系统自动调用`析构函数`;
6. 类Point的析构函数的定义原型是`~Point();`;
7. 对象成员构造函数的调用顺序取决于在这些对象在类中说明的顺序，与它们在成员初始化列表中给出的顺序`无关`;
8. 类的普通成员函数是指声明中不含`const`和`static`关键字的函数；
9. 若类X的对象x是类Y的成员对象，则执行“Y obj;”语句时，先调用类`X`的构造函数；
10. 调用封闭类的构造函数之前，必须调用`成员对象的构造函数`;
11. 若把类B的成员函数void fun()说明为类A的友元函数，则应在类A中加入语句`friend void B::fun();`;
12. 不是类中的成员函数，但却能在函数体中访问类中私有成员变量的函数是类的`友元函数`;
13. this指针始终指向调用成员函数的`对象`;

## 第四章 运算符重载
1. 在C++程序中，重载运算符[]时，不能用友元运算符来重载，只能用`成员函数`来重载;
2. 设op表示要重载的运算符，那么重载运算符的函数名是`operator op`;
3. 类型转换只能定义一个类的`成员函数`;
4. 当一元运算符的操作数，或者二元运算符的左操作数是该类的一个对象时，重载运算符一般定义为:`成员函数`
5. 一元运算符作为类成员函数时，形参的个数是：`0`

## 第五章 类的继承与派生
1. 类的继承是指派生类继承基类的`成员变量`和`成员函数`;
2. 在保护派生中，基类权限为private的成员在派生类中`不可访问`;
3. 从一个或多个以前定义的类产生新类的过程成为`派生`;
4. 基类的公有成员在派生类中的访问权限由`继承方式`决定;
5. 基类中不能被派生类继承的成员函数是`析构函数和构造函数`;
6. C++中有两种继承：一种是单继承；另一种是`多重继承`;
7. 派生类的成员一般分为两种：一部分是由自己定义的新成员；另外一部分是`从基类继承的成员`;
8. 当派生类指针指向基类对象时，为了能调用派生类的成员函数，必须进行`强制类型转换`;
9. 让派生类指针pDerived指向基类对象objBase的语句是：`pDerived = (CDerived*)&objBase`;
10. 调用派生类构造函数之前，必须调用`基类构造函数`;

## 第六章 多态与虚函数
1. 定义虚函数时使用的关键字是`virtual`;
2. 通过基类指针调用虚函数，可能会出现完全不同的行为的现象称为`动态多态`；
3. 静态联编所支持的多态性称为`编译时`的多态性;
4. 编译时的多态性通过`重载`实现;
5. 抽象类中至少要有一个`纯虚函数`;
6. 有虚函数的类，其析构函数也应该实现为`虚函数`;
7. 通过基类指针或引用调用成员函数的语句，只有当该成员函数是`虚函数`时才是多态的；
8. 如果通过基类指针或引用调用不是虚函数的成员函数，那么这条函数调用语句就是`静态`联编的；

## 第七章 输入输出流
1. C++中ostream类的直接基类是`ios`;
2. 表达式`cout<<hex`还可以表示为`cout<<setiosflages(ios_base::hex)`;
3. 要将str="Hello!"输出为"****Hello!"这样的格式，应该使用的语句是:`cout<<setfill(*)<<setw(10)<<"Hello!"`;
4. 下列程序段输出的结果是：`123.45****`
    ```cpp
    cout.fill('*');
    cout.width(10);
    cout<<setiosflags(ios::left)<<123.45;
    ```

## 第八章 文件操作
1. I/O操作分别由两个类：`ostream`和`istream`提供，由他们派生一个类`iostream`，提供双向的I/O操作，使用I/O流的程序要包含头文件`Iostream`;
2. cin是`istream`的一个对象，处理标准输出；cout、cerr和clog是`ostream`的对象，cout处理标准输出，cerr和clog都能处理标准出错信息，知识`cerr`不带缓冲，`clog`输出带缓冲。
3. 文件的I/O由`ifstream`、`ofstream`、`fstream`3个类提供，使用文件类的程序要包含头文件`fstream`。
4. 头文件`fstream.h`中包含了处理用户控制的文件操作所需要的信息。
5. 现有两条语句:
    ```cpp
    ifstream datafile;
    datafile.open("Text.txt");
    ```
    它们的等效语句是：`fstream datafile.open("Text.txt", ios_base::in)`


## 第九章 函数模板与类模板
1. 设有类模板TestClass，类型参数是T，在类体外定义其成员函数getData()时的格式是
    ```cpp
    template<class T>
    T template<class T>::getData(形参表)
    {
        函数体
    }
    ```