# 第三章 进程调度与死锁

当多个进程在系统中并发执行时，所有进程共享 CPU。当某一 CPU 上运行的进程因阻塞或进程运行结束而使 CPU 分配给其他进程使用时，如何从众多就绪的可运行进程中选择一个进程，将 CPU 分配给该进程，使系统有效运行，是多任务操作系统必须解决的问题之一。

## 3.1 进程调度的功能与时机

#### 进程调度的功能

进程调度的功能是`按照某种策略和算法`从就绪态进程中为当前空闲的 CPU 选择在其上运行的新进程。  
 进程调度功能由操作系统内核的进程调度程序完成。

#### 进程调度的时机

1）进程运行结束；2）进程阻塞；3）中断返回；4）有比当前运行进程优先级更高的进程到来；5）当前运行进程的时间片用完时；

## 3.2 进程调度算法

进程调度算法：是指从`就绪态`进程中选择一个或几个进程为其分配 CPU，使其进入`执行态`的算法。

#### 选择调度方式和算法的若干准则

1）周转时间短；2）响应时间快；3）截止时间的保证；4）系统吞吐量高；5）处理机利用率好；

#### 调度算法

1. 先来先服务调度算法（First-Come, First-Served, FCFS）

   1）调度算法  
    在进程调度种，FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。  
   2）性能分析  
    FCFS 适合长进程，不利于短进程，短进程等待时间相对于运行时间而言太长。  
    FCFS 有利于 CPU 繁忙型进程（如科学计算），不利于 I/O 繁忙型进程（如多数的事务处理）。

2. 短进程优先调度算法（Shortest-Process-First, SPF）

   1）调度算法  
    短进程优先的调度算法是从就绪队列中选择估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行完成，或发生某事件而被阻塞放弃处理机时，再重新调度。  
   2）算法优点  
    与 FCFS 算法相比，短进程优先的算法能有效降低进程的平均等待时间，提高系统的吞吐量。  
   3）算法的缺陷  
    1.对长进程不利。  
    2.不能保证紧迫进程的及时处理，因为该算法不考虑进程的紧迫程度。  
    3.进程的长短根据用户的估计而定，故不一定能真正做到短进程优先。  
   4）性能分析  
    短进程优先的调度算法比先来先服务调度算法能降低系统的平均周转时间和带权平均周转时间

3. 优先权调度算法（Priority-Scheduling Lgorithm, PSL）

   1）调度算法  
    在使用优先权调度的系统中，每个进程都有一个与之关联的优先权，系统将 CPU 分配给就绪队列中优先权值最高的进程。  
   2）优先权调度算法的类型  
    1.非抢占式优先权调度  
    在非抢占式调度的系统中，高优先权进程一旦得到处理机，则该进程便一直运行下去，直到完成或由于某事件使该进程主动放弃放弃处理机。  
    在进程运行期间，即使有更高优先权进程到来，系统也不能剥夺当前进程的 CPU 使用权。  
    2.抢占式优先权调度  
    如果新到达进程的优先权高于当前正在运行进程的优先权，那么系统会抢占 CPU，把它分配给新到达的高优先权进程。
   3）优先权的类型  
    1.静态优先权  
    2.动态优先权
   4）优先权调度算法存在的问题和解决方案  
    1.问题  
    优先权调度算法的一个主要问题是无穷阻塞，或称饥饿问题。  
    优先权调度算法会使某个低优先权进程无穷等待 CPU，平稳的高优先权进程流可以阻止低优先进程获得 CPU。  
    2.解决方案  
    低优先权进程无穷等待问题的解决方案之一是老化技术。  
    老化技术以逐渐增加在系统中等待时间很长的进程的优先级，使低优先权进程在等待时间很长的情况下，优先权变高而获得 CPU 执行。

4. 时间片轮转调度算法（Round-Robin, RR）

   1）调度算法  
    当进程的时间区间小于一个时间片的情况，进程在 CPU 上运行结束后，进程本身会自动释放 CPU。  
    当进程的时间区间大于一个时间片的情况，进程可能需要执行若干个时间片。每当进程在 CPU 上连续运行的时间等于一个时间片长度时，操作系统在时钟中断处理过程中会抢占 CPU，进行进程切换，用新的就绪进程替代当前进程，被替代的当前进程重新回到就绪队列中。  
   2）时间片大小的确定  
    选择时间片时既要考虑交互用户的需求，也要平衡系统的效率。在为调度程序确定时间片的大小时，通常需要考虑以下几个因素。  
    1.系统对响应时间的要求  
    2.就绪队列中进程的数目  
    3.系统的处理能力  
   3）时间片轮转调度算法的性能评估  
    时间片轮转调度算法的性能很大程度上依赖于时间片的大小

5. 多级队列调度

   1）调度算法  
    将就绪队列分成多个独立队列，根据进程的某些属性，如需要占用的内存大小、进程优先权或进程类型，进程会被永久地分配到一个队列。每个队列有自己的调度算法。不同的队列优先权不同，调度算法也可能不同。

6. 多级反馈队列调度

   采用多级队列调度，一旦进程进入系统，就被固定地分配到一个就绪队列中，进程在被撤销前不会在不同队列之间移动。  
   这种算法的优点是降低了进程调度的开销，但是不够灵活，对低优先权进程会存在无穷阻塞（饥饿）问题。而多级反馈队列调度算法可以弥补这些不足。

   调度算法  
    在采用多级反馈队列调度的系统中建立多个优先权不同的就绪队列，为每个队列赋予大小不同的时间片。  
    有一种反馈策略可以规定：队列优先权越高，时间片越短，时间片通常成本增长。新进程被创建后，先插入优先权最高的队列。仅当高优先权队列空时，才调度优先权次之的队列。在同一个队列中，采用时间片轮转调度算法。

## 3.3 实时系统中的调度

1. 实现实时调度的基本条件

   1）提供必要的调度信息  
   2）系统处理能力强  
   3）采用抢占式调度机制  
   4）具有快速切换机制

2. 常见的几种实时调度算法

   1）最早截止时间优先 EDF（Earliest Deadline First, EDF）算法  
    该算法是根据进程的开始截止时间确定进程的优先级。截止时间越早，进程的优先级越高，越优先获得处理机。  
   2）最低松弛度优先 LLF（Least Laxity First, LLF）算法  
    松弛度用来表示一个实时进程的紧迫程度。

## 3.4 进程切换

当进程调度程序选择到一个新的进程后，要进行进程切换，用新选择的进程替换原来的执行进程，也就是把 CPU 的控制权交给由调度程序所选择的进程。

切换进程的几个步骤：  
1）保存包括程序计数器和其他寄存器在内的 CPU 上下文环境。  
2）更新被替换进程的进程控制块。  
3）修改进程状态，把执行态改为就绪态或者阻塞态。  
4）将被替换进程的进程控制块移到就绪队列或阻塞队列。  
5）执行通过进程调度程序选择的新进程，并更新该进程的进程控制块。  
6）更新内存管理的数据结构。  
7）恢复被调度程序选中的进程的硬件上下文。

## 3.5 多处理器调度

1. 多处理器系统的类型

   1）紧密耦合的多处理器系统和松弛耦合的多处理器系统  
   2）对称多处理器系统和非对称多处理器系统

2. 多处理器系统中的进程分配方式

   1）对称多处理器系统中的进程分配方式  
   2）非对称多处理器系统中的进程分配方式

3. 进程（线程）调度方式

   1）自调度  
   2）成组调度  
   3）专用处理器分配

## 3.6 死锁

由于多个进程竞争共享资源而引起的进程不能向前推进的僵死状态称为死锁。

1. 产生死锁的原因

   进程访问资源是通过执行程序实现的。一般来说，进程按照申请资源、访问资源和释放资源的顺序使用资源。  
   产生死锁的原因为：竞争共享资源且分配资源的顺序不当。

2. 产生死锁的必要条件

   1）互斥条件  
    指一个进程在访问资源的过程中，其他进程不能访问该资源。  
   2）请求和保持条件  
    进程已经保持了至少一个资源，又提出了新的资源要求，而新请求的资源已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保存不放，使得其他进程无法使用被保持的资源。  
   3）不剥夺条件  
    进程已经获得的资源不能被剥夺，只能由进程自己释放。  
   4）环路等待条件  
    在发生死锁时，必然存在一个进程申请资源的环形链。

   只有当上诉 4 个条件同时满足时候才会发生死锁。

3. 处理死锁的基本方法

   处理死锁的基本方法有预防死锁、避免死锁、检测并解除死锁和忽略死锁问题（即假定死锁不可能在系统内发生而忽略死锁）。

   1）死锁的预防  
    死锁预防是根据前面讨论的死锁必要条件，通过保证至少其中一个条件不成立来达到预防发生死锁的目的。  
    预防死锁可以通过摈弃下列三个必要条件之一来实现：  
    1.摒弃请求和保持条件  
    2.摒弃不剥夺条件  
    3.摒弃环路等待条件

   2）死锁的避免  
    避免死锁的方法是把系统的资源分配状态分为安全状态和不安全状态，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。

4. 银行家算法
5. 死锁的检测和解除

   1）何时调用检测算法  
   2）资源分配图  
   3）死锁定理  
   4）死锁的解除

## 思考与练习

#### 填空

1. FCFS 适合` `进程，不利于` `进程。
2. 采用基于静态优先权的调度算法时，若不断有高优先权进程进入就绪队列，低优先级进程可能进入` `状态。
3. ` `算法是用来避免死锁的算法。
4. S 为死锁状态的` `条件是当且仅当 S 状态的资源分配图是不可完全简化的。

#### 简答题

1. 进程调度的功能是什么？
2. 说明什么是时间片轮转调度算法？
3. 什么是多级队列调度算法？
4. 什么是自调度方式？自调度有什么优缺点？
5. 什么是死锁？引起死锁的原因是什么？
