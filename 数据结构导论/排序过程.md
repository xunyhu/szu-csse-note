# 排序过程

## 分类

插入排序（直接插入排序）

交换排序（冒泡排序、快速排序）

选择排序（直接选择排序、 堆排序）

归并排序（二路归并排序）

## 排序过程举例

1. 冒泡排序

   设待排序的键值为 45 38 66 90 88 10 25 45。利用冒泡排序算法从小到大进行排序

   ```markdown
   **初始列表**: 45, 38, 66, 90, 88, 10, 25, 45
   **第一轮**:

   - 45 与 38 交换 → 38, 45, 66, 90, 88, 10, 25, 45
   - 45 与 66 不交换
   - 66 与 90 不交换
   - 90 与 88 交换 → 38, 45, 66, 88, 90, 10, 25, 45
   - 90 与 10 交换 → 38, 45, 66, 88, 10, 90, 25, 45
   - 90 与 25 交换 → 38, 45, 66, 88, 10, 25, 90, 45
   - 90 与 45 交换 → 38, 45, 66, 88, 10, 25, 45, 90

   **后续轮次**: 重复以上步骤，直到没有交换为止。

   最终排序结果为: **10, 25, 38, 45, 45, 66, 88, 90**。
   ```

   冒泡排序的`时间复杂度为 O(n^2)`，其中 n 是待排序元素的数量。这是因为在最坏情况下需要进行 n−1 次比较，每次比较需要 n−i 次交换。

   冒泡排序的`空间复杂度为 O(1)`，因为它是一个原地排序算法，只需要常量级别的额外空间来存储临时变量。

   冒泡排序是`稳定`的排序算法。这意味着如果`有两个相等的元素，它们在排序后仍然保持原来的相对顺序`。

2. 快速排序

   对键值序列 (72, 26, 57, 88, 42, 80, 73, 48, 60) 进行快速排序，选择最左位置的键值 72 作为基准，写出第一趟排序过程。

   ```md
   **初始列表**: 72, 26, 57, 88, 42, 80, 73, 48, 60

   **第一趟排序**:

   1. 初始化指针:

      左指针从基准的右边开始，右指针从序列末尾开始。

   2. 分区过程:

      左指针移动，直到找到一个大于或等于基准的元素。
      右指针移动，直到找到一个小于或等于基准的元素。
      进行交换，直到左右指针相遇。

      初始列表: 72, 26, 57, 88, 42, 80, 73, 48, 60
      右指针->60, 左指针->88
      右指针->60, 小于 72, 交换 60, 26, 57, 88, 42, 80, 73, 48, 72
      左指针->88, 大于 72, 交换 60, 26, 57, 72, 42, 80, 73, 48, 88
      右指针移动->48
      右指针->48, 左指针->80
      右指针->48, 小于 72, 交换 60, 26, 57, 48, 42, 80, 73, 72, 88
      右指针移动->73
      右指针->73, 左指针->80, 由于左指针大于基准，右指针小于基准，所以不需要交换。继续移动左指针和右指针，直到它们相遇
      当左指针和右指针相遇时，找到合适的位置放置基准。  
      交换基准 72 和左指针指向的位置（80），得到：60, 26, 57, 48, 42, 72, 73, 80, 88
   ```

   快速排序算法在平均情况下的`时间复杂度为 O(nlog2^n)`，在最坏情况下的`时间复杂度为 O(n^2)`

   快速排序是`不稳定`的排序算法，因为在分区过程中，相同元素的相对顺序可能会被改变。

   快速排序的`平均空间复杂度为 O(logn)`，在最坏情况下的`时间空间复杂度为 O(n)`

3. 直接插入排序

   对于给定的一组键值：25，11，22，34，5，44，76，61，100，3，14，120，请写出直接插入排序结果。

   ```md
   **初始列表**: 25, 11, 22, 34, 5, 44, 76, 61, 100, 3, 14, 120

   1. **第一轮**: 11 插入到 25 前面 → 11, 25, 22, 34, 5, 44, 76, 61, 100, 3, 14, 120
   2. **第二轮**: 22 插入到 25 前面 → 11, 22, 25, 34, 5, 44, 76, 61, 100, 3, 14, 120
   3. **第三轮**: 34 保持不变 → 11, 22, 25, 34, 5, 44, 76, 61, 100, 3, 14, 120
   4. **第四轮**: 5 插入到最前面 → 5, 11, 22, 25, 34, 44, 76, 61, 100, 3, 14, 120
   5. **第五轮**: 44 保持不变 → 5, 11, 22, 25, 34, 44, 76, 61, 100, 3, 14, 120
   6. **第六轮**: 76 保持不变 → 5, 11, 22, 25, 34, 44, 76, 61, 100, 3, 14, 120
   7. **第七轮**: 61 插入到 76 前面 → 5, 11, 22, 25, 34, 44, 61, 76, 100, 3, 14, 120
   8. **第八轮**: 100 保持不变 → 5, 11, 22, 25, 34, 44, 61, 76, 100, 3, 14, 120
   9. **第九轮**: 3 插入到最前面 → 3, 5, 11, 22, 25, 34, 44, 61, 76, 100, 14, 120
   10. **第十轮**: 14 插入到 22 前面 → 3, 5, 11, 14, 22, 25, 34, 44, 61, 76, 100, 120
   11. **第十一轮**: 120 保持不变 → 3, 5, 11, 14, 22, 25, 34, 44, 61, 76, 100, 120

   最终排序结果为: **3, 5, 11, 14, 22, 25, 34, 44, 61, 76, 100, 120**。
   ```

   直接插入排序的`时间复杂度为 O(n^2)`，其中 n 是待排序元素的数量，最坏情况下需要进行多次比较和移动。

   直接插入排序的`空间复杂度为 O(1)`，因为它是一个原地排序算法，仅需常量级的额外空间来存储临时变量。

   直接插入排序是`稳定`的排序算法，保持相同元素的原始相对顺序。

4. 直接选择排序

   对于给定的一组键值：83，40，63，13，84，35，96，57，39，79，61，15，请写出直接选择排序的排序结果

   ```md
   直接选择排序的步骤如下：

   **初始列表**: 83, 40, 63, 13, 84, 35, 96, 57, 39, 79, 61, 15

   1. **第一轮**: 找到最小值 13，交换到首位 → 13, 40, 63, 83, 84, 35, 96, 57, 39, 79, 61, 15
   2. **第二轮**: 找到最小值 15，交换到第二位 → 13, 15, 63, 83, 84, 35, 96, 57, 39, 79, 61, 40
   3. **第三轮**: 找到最小值 35，交换到第三位 → 13, 15, 35, 83, 84, 63, 96, 57, 39, 79, 61, 40
   4. **第四轮**: 找到最小值 39，交换到第四位 → 13, 15, 35, 39, 84, 63, 96, 57, 83, 79, 61, 40
   5. **第五轮**: 找到最小值 57，交换到第五位 → 13, 15, 35, 39, 57, 63, 96, 84, 83, 79, 61, 40
   6. **第六轮**: 找到最小值 61，交换到第六位 → 13, 15, 35, 39, 57, 61, 96, 84, 83, 79, 63, 40
   7. **第七轮**: 找到最小值 63，交换到第七位 → 13, 15, 35, 39, 57, 61, 63, 84, 83, 79, 96, 40
   8. **第八轮**: 找到最小值 79，交换到第八位 → 13, 15, 35, 39, 57, 61, 63, 79, 83, 84, 96, 40
   9. **第九轮**: 找到最小值 83，交换到第九位 → 13, 15, 35, 39, 57, 61, 63, 79, 83, 84, 96, 40
   10. **第十轮**: 找到最小值 84，交换到第十位 → 13, 15, 35, 39, 57, 61, 63, 79, 83, 84, 96, 40
   11. **第十一轮**: 找到最小值 96，交换到最后一位 → 13, 15, 35, 39, 57, 61, 63, 79, 83, 84, 40, 96
   12. **第十二轮**: 40 已在正确位置 → 13, 15, 35, 39, 57, 61, 63, 79, 83, 84, 40, 96

   最终排序结果为: **13, 15, 35, 39, 40, 57, 61, 63, 79, 83, 84, 96**。
   ```

   直接选择排序的`时间复杂度为 O(n^2)`，其中 n 是待排序元素的数量。这个复杂度来自于需要在每一轮中进行 n-i 次比较。

   空间复杂度为`空间复杂度为 O(1)`，因为它是一个原地排序算法，仅需常量级别的额外空间来存储临时变量。

   直接选择排序是`不稳定`的排序算法，因为在选择最小值并交换位置时，可能会改变相同元素的相对顺序。

5. 二路归并排序

   将一组键值{83，69，41，22，15，33，8，76}应用二路归并排序算法从小到大排序，试写出各趟排序的结果。

   ```md
   **初始序列**：83, 69, 41, 22, 15, 33, 8, 76

   1. 将序列分成两个部分 {83, 69, 41, 22} 和 {15, 33, 8, 76}
   2. 对每个部分进行进一步分割：
      - 左部分:{83, 69} 和 {41, 22}
      - 右部分:{15, 33} 和 {8, 76}
   3. 继续分割到单个元素
      - 左部分
        {83} 和 {69} -> {69, 83} （合并结果）
        {41} 和 {22} -> {22, 41} （合并结果）
      - 右部分
        {15} 和 {33} -> {15, 33} （合并结果）
        {8} 和 {76} -> {8, 76} （合并结果）
   4. 开始合并各部分
      - 合并左部分： {69, 83} 和 {22, 41} -> {22, 41, 69, 83}
      - 合并右部分：{15, 33} 和 {8, 76} -> {8, 15, 33, 76}
   5. 最后，将两个已排序的部分合并 {22, 41, 69, 83} 和 {8, 15, 33, 76}
      合并步骤如下：
      - 从左部分取 22 和右部分的 8，8 比 22 小，所以先放 8：{8}
      - 接着取 15: {8, 15}
      - 接着取 22: {8, 15, 22}
      - 接着取 33: {8, 15, 22, 33}
      - 接着取 41: {8, 15, 22, 33, 41}
      - 接着取 69: {8, 15, 22, 33, 41, 69}
      - 接着取 76: {8, 15, 22, 33, 41, 69, 76}
      - 最后取 83: {8, 15, 22, 33, 41, 69, 76, 83}
   ```

   归并排序的时间复杂度在所有情况下都是`O(nlogn)`因为每次合并操作需要线性时间，且每次分割都将数组分为两半。

   空间复杂度为`空间复杂度为 O(n)`，归并排序需要额外的空间来存储临时数组，以便在合并时使用。

   归并排序是`稳定`的排序算法，意味着相同的元素在排序后保持原来的相对顺序。合并过程中，当处理相等元素时，来自`左半部分的元素会先被放入结果中`，从而保持稳定性。
