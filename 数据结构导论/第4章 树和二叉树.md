# 第 4 章 树和二叉树

## 4.1 树的基本概念

线性结构中的一个结点至多有一个直接后继，而`树形结构中一个结点可以有一个或多个直接后继`。

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/image-204.jpeg)

### 4.1.1 树的概念

`树(Tree)`是一类重要的数据结构，其定义如下:树是 n(n≥0)个结点的有限集合，一棵树满足以下两个条件:

1. 有且仅有一个根节点。
2. 除根节点外，其他每个节点都有且只有一个父节点。

`森林(Forest)`是 m(m≥0)棵互不相交的树的集合。树的每个结点的子树是森林。删除一个非空树的根结点，它的子树便构成森林。

### 4.1.2 树的相关术语

`结点的度`: 树上任一`结点所拥有的子树的数目`称为该结点的度。

`叶子`: 度为 0 的结点称为叶子或终端结点。

`树的度`: 一棵树中`所有结点的度的最大值`称为该树的度。

`有序树`: 若树中各`结点的子树从左到右是有次序的，不能互换`，称为有序树。有序树中最左边子树的根称为第 1 个孩子，左边第 i 个子树的根称为第 i 个孩子。

`无序树`: 若树中各`结点的子树是无次序的`，可以互换，则称为无序树。

`树的基本运算`包括:

1. 求根 Root(T): 求树 T 的根结点
2. 求双亲 Parent(T，X): 求结点 X 在树 T 上的双亲结点; 若 X 是树 T 的根或 X 不在 T 上，则结果为一特殊标志
3. 求孩子 Child(T，X，i): 求树 T 上结点 X 的第 i 个孩子结点; 若 X 不在 T 上或 X 没有第 i 个孩子，则结果为一特殊标志
4. 建树 Create(X,Tp, …,Ty), k>1:建立一棵以 X 为根，以 T,…,T 为第 1,.，k 棵子树的树
5. 剪枝 Delete(T，X，i): 删除树 T 上结点 X 的第 i 棵子树;若 T 无第 i 棵子树，则为空操作
6. 遍历 TraverseTree(T): 遍历树，即访问树中每个结点，且每个结点仅被访问一次

## 4.2 二叉树

### 4.2.1 二叉树的基本概念

`二叉树(Binary Tree)`是 n(n≥0)个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树也均为二叉树。

1. `每个节点最多有两个子节点，分别称为左子节点和右子节点`。
2. 二叉树的子节点位置不固定，可以为空，也可以只有一个子节点。
3. 每个节点的左子树和右子树都是二叉树。

`二叉树的基本运算`包括:

1. 初始化 Initiate(BT)：建立一颗空二叉树
2. 求双亲 Parent(BT, X)：求出二叉树 BT 上结点 X 的双亲结点，若 X 是 BT 的根或 X 根本不是 BT 上的结点，运算结果为 NULL。
3. 求左孩子 Lchild(BT, X)和求右孩子 Rchild(BT, X)：分别求出二叉树 BT 上结点 X 的左、右孩子；若 X 为 BT 的叶子或 X 不在 BT 上，运算结果为 NULL。
4. 建二叉树 Create(BT):建立一棵二叉树 BT
5. `先序遍历 PreOrder(BT)`:按先序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
6. `中序遍历 InOrder(BT)`:按中序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
7. `后序遍历 PostOrder(BT)`:按后序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
8. 层次遍历 LevelOrder(BT):按层从上往下，同一层中结点按从左往右的顺序，对二叉树进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作

### 4.2.2 二叉树的性质

## 4.3 二叉树的存储结构

二叉树通常有两类存储结构:顺序存储结构和链式存储结构。链式存储结构在插入删除结点时较方便，在某些情况下，二叉树的顺序存储结构也很有用。

### 4.3.1 二叉树的顺序存储结构

二叉树的顺序存储结构可以用一维数组来实现，二叉树上的结点按某种次序分别存入该数组的各个单元中。

### 4.3.2 二叉树的链式存储结构

```c
// 定义二叉树节点结构
typedef struct TreeNode {
    int data;           // 数据域
    struct TreeNode* left;  // 左孩子指针
    struct TreeNode* right; // 右孩子指针
} TreeNode;

// 创建一个新节点
TreeNode* createNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```

## 4.4 二叉树的遍历

### 4.4.1 二叉树遍历的递归实现

1. 先序遍历

   先序遍历的规则是：先访问根节点，然后遍历左子树，最后遍历右子树。

2. 中序遍历

   中序遍历的规则是：先遍历左子树，然后访问根节点，最后遍历右子树。

3. 后序遍历

   后序遍历的规则是：先遍历左子树，然后遍历右子树，最后访问根节点。

上述三种遍历算法均可实现访问一棵二叉树中每个结点的访问，且每个结点仅被访问一次，由于访问根结点的操作 visit(bt)在算法中的位置不同，因此访问根结点的顺序不同，最后得到的结点访问序列也不同。

### 4.4.2 二叉树的层次遍历

所谓二叉树的层次遍历，是指从二叉树的根结点的这一层开始，逐层向下遍历，在每一层上按从左到右的顺序对结点逐个访问。

### 4.4.3 二叉树遍历的非递归实现

### 4.4.4 应用举例

## 4.5 树和森林

### 4.5.1 树的存储结构

1. 孩子链表表示法
2. 孩子兄弟链表表示法
3. 双亲表示法

   双亲表示法由一个一维数组构成。数组的每个分量包含两个域:数据域和双亲域。数据域用于存储树上一个结点中数据元素，双亲域用于存储本结点的双亲结点在数组中的序号(下标值)。

### 4.5.2 树、森林与二叉树的关系

1. 树转换成二叉树

   任何一棵树可唯一地与一棵二叉树对应。相应地，一棵二叉树也唯一地对应一棵树，即树与二叉树可以互相转换

   将树转换成二叉树的方法如下:
   (1)将所有兄弟结点连接起来;  
    (2)保留第一个兄弟结点与父结点的连接，断开其他兄弟结点与父结点的连接，然后以根结点为轴心按顺时针的方向旋转 45° 角。

2. 森林转换成二叉树
3. 二叉树转换成森林

### 4.5.3 树和森林的遍历

1. 树的遍历
2. 森林的遍历

## 4.6 判定树和哈夫曼树

### 4.6.1 分类与判定树

树有广泛的应用，其中一种重要的应用是描述分类过程。分类是一种常用运算，其作用是将输入数据按预定的标准划分成不同的种类。例如，将某地区的人口按他们的年龄值 age 确定其类别就是一个分类问题，见表 4-1。`用于描述分类过程的二叉树称为判定树`。

是否存在`计算量最小(即平均比较次数最少)的判定树`呢?如果存在，怎样构造出这种判定树呢?下一节讨论的哈夫曼树和哈夫曼算法将给出这个答案。

### 4.6.2 哈夫曼(Huffman)树与哈夫曼算法

### 4.6.3 哈夫曼编码

## 4.7 小结
