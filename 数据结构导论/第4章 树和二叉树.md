# 第 4 章 树和二叉树

## 4.1 树的基本概念

线性结构中的一个结点至多有一个直接后继，而`树形结构中一个结点可以有一个或多个直接后继`。

### 4.1.1 树的概念

树（Tree）是 n（n≥0）个结点的有限集，它或为空树（n=0）​；或为非空树，对于非空树 T：

（1）有且仅有一个称之为根的结点；

（2）除根结点以外的其余结点可分为 m（m>0）个互不相交的有限集 T1, T2, …, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）​。

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。

树还可有其他的表示形式，如图所示为树的各种表示。其中（a）是以嵌套集合（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）的形式表示的；​（b）是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；​（c）用的是凹入表示法（类似书的编目）​。

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_122.jpeg)

### 4.1.2 树的相关术语

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_121.jpeg)

（1）结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图中的 A、B、C、D 等。​（下面术语中均以图 5.1（b）为例来说明）

（2）结点的度：结点拥有的子树数称为结点的度。例如，A 的度为 3，C 的度为 1，F 的度为 0。

（3）树的度：树的度是树内各结点度的最大值。图 5.1（b）所示的树的度为 3。

```mathematica
   一棵度为3的树

         A
      /  |  \
      B   C   D
   /|\   |
   E F G  H

```

（4）叶子：度为 0 的结点称为叶子或终端结点。结点 K、L、F、G、M、I、J 都是树的叶子。

（5）非终端结点：度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

（6）双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B 的双亲为 A，B 的孩子有 E 和 F。

（7）兄弟：同一个双亲的孩子之间互称兄弟。例如，H、I 和 J 互为兄弟。

（8）祖先：从根到该结点所经分支上的所有结点。例如，M 的祖先为 A、D 和 H。

（9）子孙：以某结点为根的子树中的任一结点都称为该结点的子孙。如 B 的子孙为 E、K、L 和 F。

（10）层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。

（11）堂兄弟：双亲在同一层的结点互为堂兄弟。例如，结点 G 与 E、F、H、I、J 互为堂兄弟。

（12）树的深度：树中结点的最大层次称为树的深度或高度。图 5.1（b）所示的树的深度为 4。

（13）有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换）​，则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

（14）`森林`：是 m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。

就逻辑结构而言，任何一棵树都是一个二元组 Tree ＝(root ,F)，其中 root 是数据元素，称作树的根结点；F 是 m（m≥0）棵树的森林，F=(T1, T2, …, Tm)，其中 Ti=(ri, Fi)称作根 root 的第 i 棵子树；当 m≠0 时，在树根和其子树森林之间存在下列关系：RF={<root,ri>|i=1,2,…,m,m>0}

`树的基本运算`包括:

1. 求根 Root(T): 求树 T 的根结点
2. 求双亲 Parent(T，X): 求结点 X 在树 T 上的双亲结点; 若 X 是树 T 的根或 X 不在 T 上，则结果为一特殊标志
3. 求孩子 Child(T，X，i): 求树 T 上结点 X 的第 i 个孩子结点; 若 X 不在 T 上或 X 没有第 i 个孩子，则结果为一特殊标志
4. 建树 Create(X,Tp, …,Ty), k>1:建立一棵以 X 为根，以 T,…,T 为第 1,.，k 棵子树的树
5. 剪枝 Delete(T，X，i): 删除树 T 上结点 X 的第 i 棵子树;若 T 无第 i 棵子树，则为空操作
6. 遍历 TraverseTree(T): 遍历树，即访问树中每个结点，且每个结点仅被访问一次

## 4.2 二叉树

### 4.2.1 二叉树的基本概念

二叉树（Binary Tree）是 n（n≥0）个结点所构成的集合，它或为空树（n=0）​；或为非空树，对于非空树 T：

（1）有且仅有一个称之为根的结点；

（2）除根结点以外的其余结点分为两个互不相交的子集 T1 和 T2，分别称为 T 的左子树和右子树，且 T1 和 T2 本身又都是二叉树。

二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：

（1）二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点）​；

（2）二叉树的子树有左右之分，其次序不能任意颠倒。

```mathematica
一个简单的二叉树结构

      A
     / \
    B   C
   / \
  D   E

```

二叉树的 5 种基本形态

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_123.jpeg)

两种特殊形态的二叉树，它们是满二叉树和完全二叉树。

满二叉树：深度为 k 且含有 2<sup>k−1</sup> 个结点的二叉树。图 5.6（a）所示是一棵深度为 4 的满二叉树。

满二叉树的特点是：每一层上的结点数都是最大结点数，即每一层 i 的结点数都具有最大值 2<sup>i−1</sup>。可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。由此可引出完全二叉树的定义。

完全二叉树：深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树。图 5.6（b）所示为一棵深度为 4 的完全二叉树。

完全二叉树的特点是：

（1）叶子结点只可能在层次最大的两层上出现；

（2）对任一结点，若其右分支下的子孙的最大层次为 l，则其左分支下的子孙的最大层次必为 l 或 l+1。图 5.6 中（c）和（d）不是完全二叉树。

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_130.jpeg)

`二叉树的基本运算`包括:

1. 初始化 Initiate(BT)：建立一颗空二叉树
2. 求双亲 Parent(BT, X)：求出二叉树 BT 上结点 X 的双亲结点，若 X 是 BT 的根或 X 根本不是 BT 上的结点，运算结果为 NULL。
3. 求左孩子 Lchild(BT, X)和求右孩子 Rchild(BT, X)：分别求出二叉树 BT 上结点 X 的左、右孩子；若 X 为 BT 的叶子或 X 不在 BT 上，运算结果为 NULL。
4. 建二叉树 Create(BT):建立一棵二叉树 BT
5. `先序遍历 PreOrder(BT)`:按先序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
6. `中序遍历 InOrder(BT)`:按中序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
7. `后序遍历 PostOrder(BT)`:按后序对二叉树 BT 进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作
8. 层次遍历 LevelOrder(BT):按层从上往下，同一层中结点按从左往右的顺序，对二叉树进行遍历，每个结点被访问一次且仅被访问一次，若 BT 为空，则运算为空操作

### 4.2.2 二叉树的性质

二叉树具有下列重要特性：

`性质 1` 在二叉树的第 i 层上至多有 2<sup>i−1</sup> 个结点（i≥1）​。

`性质 2` 深度为 k 的二叉树至多有 2<sup>k−1</sup> 个结点（k≥1）​。

`性质 3` 对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

`性质 4` 具有 n 个结点的完全二叉树的深度为 log2<sup>n</sup> + 1

`性质 5` 如果对一棵有 n 个结点的完全二叉树（其深度为 log2<sup>n</sup> + 1）的结点按层序编号（从第 1 层到第 log2<sup>n</sup> + 1 层，每层从左到右）​，则对任一结点 i（1≤i≤n）​，有:

（1）如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲 PARENT(i)是结点 i/2。

（2）如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）​；否则其左孩子 LCHILD(i)是结点 2i。

（3）如果 2i+1>n，则结点 i 无右孩子；否则其右孩子 RCHILD(i)是结点 2i+1。

## 4.3 二叉树的存储结构

类似线性表，二叉树的存储结构也可采用顺序存储和链式存储两种方式。

### 4.3.1 二叉树的顺序存储结构

```c++
//-----二叉树的顺序存储表示-----
#define MAXTSIZE 100 //二叉树的最大结点数
typedef TElemType SqBiTree[MAXTSIZE]; //0 号单元存储根结点
SqBiTree bt；
```

顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为 k 且只有 k 个结点的单支树（树中不存在度为 2 的结点）却需要长度为 2k−1 的一维数组。这造成了存储空间的极大浪费，所以对于一般二叉树，更适合采取下面的链式存储结构。

### 4.3.2 二叉树的链式存储结构

设计不同的结点结构可构成不同形式的链式存储结构。

二叉树的结点及其存储结构

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_140.jpeg)

链表存储结构

![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_141.jpeg)

```c
// 定义二叉树节点结构
typedef struct TreeNode {
    int data;           // 数据域
    struct TreeNode* left;  // 左孩子指针
    struct TreeNode* right; // 右孩子指针
} TreeNode;

// 创建一个新节点
TreeNode* createNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```

## 4.4 二叉树的遍历

遍历二叉树（traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。

### 4.4.1 二叉树遍历的递归实现

1. 先序遍历

   先序遍历的规则是：先访问根节点，然后遍历左子树，最后遍历右子树。

2. 中序遍历

   中序遍历的规则是：先遍历左子树，然后访问根节点，最后遍历右子树。

3. 后序遍历

   后序遍历的规则是：先遍历左子树，然后遍历右子树，最后访问根节点。

上述三种遍历算法均可实现访问一棵二叉树中每个结点的访问，且每个结点仅被访问一次，由于访问根结点的操作 visit(bt)在算法中的位置不同，因此访问根结点的顺序不同，最后得到的结点访问序列也不同。

### 4.4.2 二叉树的层次遍历

所谓二叉树的层次遍历，是指从二叉树的根结点的这一层开始，逐层向下遍历，在每一层上按从左到右的顺序对结点逐个访问。

### 4.4.3 二叉树遍历的非递归实现

### 4.4.4 应用举例

## 4.5 树和森林

### 4.5.1 树的存储结构

1. 双亲表示法

   这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域 data 外，还附设一个 parent 域用以指示其双亲结点的位置，其结点形式如图 5.18 所示。

   ![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_153.jpeg)

   例如，图 5.19 所示为一棵树及其双亲表示的存储结构。

   ![image](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_154.jpeg)

2. 孩子表示法

   由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如图 5.20 所示的两种结点格式。

3. 孩子兄弟法

   又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。

### 4.5.2 树、森林与二叉树的关系

1. 树转换成二叉树

   任何一棵树可唯一地与一棵二叉树对应。相应地，一棵二叉树也唯一地对应一棵树，即树与二叉树可以互相转换

   将树转换成二叉树的方法如下:
   (1)将所有兄弟结点连接起来;  
    (2)保留第一个兄弟结点与父结点的连接，断开其他兄弟结点与父结点的连接，然后以根结点为轴心按顺时针的方向旋转 45° 角。

2. 森林转换成二叉树
3. 二叉树转换成森林

### 4.5.3 树和森林的遍历

1. 树的遍历
2. 森林的遍历

## 4.6 判定树和哈夫曼树

### 4.6.1 分类与判定树

树有广泛的应用，其中一种重要的应用是描述分类过程。分类是一种常用运算，其作用是将输入数据按预定的标准划分成不同的种类。例如，将某地区的人口按他们的年龄值 age 确定其类别就是一个分类问题，见表 4-1。`用于描述分类过程的二叉树称为判定树`。

是否存在`计算量最小(即平均比较次数最少)的判定树`呢?如果存在，怎样构造出这种判定树呢?下一节讨论的哈夫曼树和哈夫曼算法将给出这个答案。

### 4.6.2 哈夫曼(Huffman)树与哈夫曼算法

1. 哈夫曼树的基本概念

   哈夫曼（Huffman）树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。哈夫曼树的定义，涉及路径、路径长度、权等概念，

   下面先给出这些概念的定义，然后再介绍哈夫曼树。

   （1）路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。

   （2）路径长度：路径上的分支数目称作路径长度。

   （3）树的路径长度：从树根到每一结点的路径长度之和。

   （4）权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。

   （5）结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。

   （6）树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作

   ![插图](https://szu-csse-1305214533.cos.ap-guangzhou.myqcloud.com/data-struct%2Fepub_31151916_160.jpeg)。

   （7）哈夫曼树：假设有 m 个权值{w1, w2,…, wm}，可以构造一棵含 n 个叶子结点的二叉树，每个叶子结点的权为 wi，则其中带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树。

2. 哈夫曼树的构造算法

### 4.6.3 哈夫曼编码

## 4.7 小结
