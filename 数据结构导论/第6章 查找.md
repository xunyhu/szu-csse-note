# 第 6 章 查找

## 6.1 基本概念

查找表是由同一类型的数据元素构成的集合，它是一种以查找为“核心”，同时包括其他运算的非常灵活的数据结构。

作为一种数据结构，查找表的逻辑结构是`集合`，对查找表进行的操作包括`查找`表中某一元素、`读取`表中“特定”数据元素、`插入`和`删除`一个数据元素。若对查找表只进行前两项操作，则称为`静态查找表`；若对查找表进行前四项操作，则称为`动态查找表`。

## 6.2 静态查找表

### 6.2.1 顺序表上的查找

静态查找表最简单的实现方法是以顺序表作为存储结构，这里只考虑查找的实现。

静态查找表顺序存储结构的类型定义如下:

```c
const int Maxsize = 20; //静态查找表的表长
typedef struct {
    KeyType key;//关键字
    ...   //其他域
} TableElem

typedef struct {
  TableElem elem[Maxsize+1];
  int n;  //最后一个数据元素的下标
} SqTable
```

这里，将静态查找表中的数据元素存放在上述数组的第 1 到第 n 个单元中，第 n+1 到最后一个单元为备用区(空闲区)，如图 6-1 所示。数组的第 0 个单元，用于设置“岗哨”，以便简化查找运算的实现。

```c
int SearchSqTable(SqTable T，KeyType key)
{
  /*在顺序表T中,从后往前査找键值等于key的数据元素,若找到,则返回该元素在T中的位置,否则返回0，标记查找不成功*/

  т.elem[0].key = key;  //设置岗哨
  i=T.n;                //设置比较位置初值
  while (T.elem[i].key!-key)
    i--;                //未找到时,修改比较位置继续查找

  return i;             //返回查找位置
}
```

若键值在顺序表的第个位置上，则查找长度为 1，而如果键值在顺序表的第 1 个位置上，查找长度为。鉴于这种情况，可以将`“查找成功时的平均查找长度”(记为 ASL)`作为评价查找算法时间性能的度量。

ASL 定义:为找到数据元素在查找表中的位置，与给定值进行比较的键值个数的期望值。

顺序查找算法的平均 ASL 为: `(n+1)/2`

### 6.2.2 有序表上的查找

如果顺序表中数据元素是按照键值大小的顺序排列的，则称为有序表。在这种存储表示下，查找运算可以用效率更高的`二分查找法`实现。

二分查找(Binary Search)的查找过程为每次用给定值与处在表的中间位置的数据元素的键值进行比较，确定给定值的所在区间，然后逐步缩小查找区间。重复以上过程直至找到或确认找不到该数据元素为止。

假定有序表是按键值从小到大有序。二分查找算法如下:

```c
int SearchBin(saTable T,KeyType key)
{
/*在有序表T中,用二分査找法査找键值等于key的元素,变量low,hig分别标记查找区间的下界和上界*/

  int low,high;
  low=1; high=T.n;   //设置查找区间初值

  while(low<=high) //区间长度不为0时继续查找
  {
      mid=(low+high)/2;  //对区间进行折半，“/“为整除
      if(key == T.elem[mid].key) return mid;
      else if(key < T.elem[mid].key) high = mid-1;   //在前半区间查找
        else low = mid+1;                           //在后半区间查找
  }

  return 0;   //查找不成功,则返回0
}
```

二分查找算法的平均 ASL 为: `log2^(n+1) - 1`

二分查找的时间性能比顺序查找好。而相比顺序查找而言，二分查找要求表元素是排好序的。`当采用的存储结构不是顺序表，或者顺序表中元素未按键值的次序(递增或递减)排列时，则不能进行二分查找`。

### 6.2.3 索引顺序表上的查找

索引顺序表是结合了顺序查找和二分查找的优点构造的一种带索引的存储结构。

总之，静态查找表的上述三种不同实现各有优缺点。其中，顺序查找效率最低但限制最少。二分查找效率最高，但限制最强。而分块查找则介于上述二者之间。在实际应用中应根据需要加以选择。

## 6.3 二叉排序树

静态查找表一旦生成之后，所含数据元素(在检索阶段内)是固定不变的。本节将介绍一种实现动态查找的树表--二叉排序树，这种树表的结构本身是在查找过程中动态生成的，即对于给定 key，若表中存在与 key 相等的元素，则查找成功，不
然，插入关键字等于 key 的元素。本节主要介绍二叉排序树概念，并讨论在这种树表上如何实现动态查找表的查找和插入运算。

一棵`二叉排序树(Binary Sort Tree)`(又称二叉查找树)或者是一棵空二叉树,或者是`具有下列性质`的二叉树:

(1)若它的左子树不空，则左子树上所有结点的键值均小于它的根结点键值

(2)若它的右子树不空，则右子树上所有结点的键值均大于它的根结点键值:

(3)根的左、右子树也分别为二叉排序树。

二叉排序树的二叉链表的类型定义如下:

```c
typedef struct btnode
{
  KeyType key;
  struct btnode *lchild,*rchild;  //指向左右孩子的指针
} BSTNode,*BinTree;             //BinTree为指向二叉链表结点的指针类型
BinTree bst;                  //bst 为指向二叉排序树根结点的指针
```

1. 二叉排序树上的查找

   由于二叉排序树的特点，要找键值比某结点键值小(大)的结点，只需通过此结点的左指针(右指针)到它的左(右)子树中去找。所以查找操作的递归实现较为简单。算法描述如下:

   ```c
      BinTree earchBsT(BinTree bst, KeyType key)
      {
        /*在根指针bst所指的二叉排序树上递归地査找键值等于key的结点。若成功,则返回指向该结点的指针,否则返回空指针*/

        if (bst == NULL) return NULL;    //不成功时返回 NULL 作为标记
        else if(key == bst->key) return bst;    //成功时返回结点地址
            else if(key < bst->key)
                return SearchBST(bst->lchild,key);//继续在左子树中査找
              else
                return SearchBST(bst->rchild,key);//继续在右子树中査找
      }
   ```

2. 二叉排序树的插入

   由于二叉排序树这种动态树表是在查找过程中，不断地往树中插入不存在的键值而形成的，所以`插入算法必须包含查找过程，并且是在查找不成功时进行插入新结点`的操作。在二叉排序树上进行插入的原则是:必须要保证插入一个新结点后，仍为一棵二叉
   排序树。这个结点是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子。

3. 二叉排序树的查找分析

   二叉排序树的`平均查找长度 ASL <= 1 + log2^n`

## 6.4 散列表

在前面讨论的结构(顺序表、树表等)中，查找数据元素时要进行一系列键值比较的过程。为了使数据元素的存储位置和键值之间建立某种联系，以减少比较次数，本节介绍用散列技术实现动态查找表。

`散列表（Hash table，也叫哈希表）`，是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。所以，利用散列表进行查找的`基本出发点是减少查找过程中的比较次数`。

数据元素的键值和存储位置之间建立的对应关系称为`散列函数`，用键值`通过散列函数`获取存储位置的这种存储方式`构造的存储结构称为散列表(HashTable)`，这一映射过程称为`散列`。如果选定了某个散列函数及相应的散列表，则对每个数据元素 X，数值 H(X.key)就是 X 在散列表 L 中的存储位置，这个存储位置也称为散列地址。

理想的情况是，应用的散列函数使每个键值与散列地址是一一对应的，但在实际应用中,这种情况很少出现。设有散列函数 日 和键值 k、kz,若 k¡≠k,但是 H(k)=H(kz)，则称这种现象为冲突，且`称 k、k,是相对于 H 的同义词`。因为，散列函数是从键值集合到地址集合的映像，所以在一般情况下，冲突只能尽可能减少而不能完全避免。因此，采用散列技术时需要考虑两个问题:

第一，如何构造(选择)“均匀的”散列函数? 第二，用什么方法有效地解决冲突?

### 6.4.1 常用散列法

构造散列函数的方法很多，若对于键值集合中的任一个键值，经散列函数映射到地址集合中任何一个地址的概率是相等的，则称此种散列函数是均匀的。这里介绍几种常用的散列函数的构造方法，按这些方法构造出来的散列函数计算简单而且比较均匀。以下假定散列地址是自然数，另外，假定键值也都是自然数。

1. 数字分析法
2. 除留余数法

   除留余数法是一种简单有效且最常用的构造方法，其方法是选择一个不大于散列表长 n 的正整数 p，以键值除以 p 所得的余数作为散列地址，即 `H(key)=key mod p(p≤n)` mod 是取余数运算，在 C 语言中，这一运算符是“%”。

   值得注意的是这一方法的`关键在于 p 的选取`。若 p 选的不合适，容易发生冲突。如选 p 为偶数，则所得的散列函数总是将奇数键值映射成奇数地址，偶数键值映射为偶数地址，因而增加了冲突的机会。`通常选 p 为小于散列表长度 n 的素数`。

3. 平方取中法
4. 基数转换法

### 6.4.2 散列表的实现

由于冲突不可避免，所以采用散列技术需考虑的第二个主要问题是如何解决冲突。假设散列表的地址集为 0~(n 一 1)，冲突是指由键值得到的散列地址上已存有元素，则解决冲突就是为该键值的元素找到一个空闲单元的散列地址。在解决冲突的过程中可能得到一个地址序列 H，i=1，2，3，…，k(0≤H≤n-1)，在解决冲突时，若得到的某个散列地址仍然发生冲突，则再求下一个地址 H+1，若仍冲突再求得 H+2。以此类推直到不发生冲突为止，这时得到的散列地址即为该元素在表中的地址。通常用来解决冲突的方法有以下几种:

1. 线性探测法

   对任何键值 key，设 H(key)=d，设散列表的容量为 m，则线性探测法生成的后继散列地址序列为 d+1，d+2，…，m-l，0，1，…，d-1

   用线性探测法生成后继散列地址计算简单，但由于探测的是一个连续的地址序列，这也引出新的问题。如图 6-8 中的 30 和 29 本来不是同义词，但是发生了`冲突`，`这种非同义词之间对同一个散列地址的争夺现象称为“堆积”`。

   `为了减少堆积`的机会，`应设法使后继散列地址尽量均匀地分散在整个散列表中`。

2. 二次探测法

   二次探测法的基本思想:生成的后继散列地址不是连续的，而是跳跃式的，以便为后续数据元素留下空间从而减少堆积。按照二次探测法，键值 key 的散列地址序列为 d0=H(key)； di=(d0+i) mod m

   二次探测法的`缺点是不易探测到整个散列表的所有空间`，也就是说，上述后继散列地址可能难以包括散列表的所有存储位置。

3. 链地址法

   链地址法是对每一个同义词都建一个单链表来解决冲突

4. 多重散列法

   此法要求设立多个散列函数 H，i=1，…，k。当给定值 key 与散列表中的某个键值是相对于某个散列函数日;的同义词而发生冲突时，继续计算这个给定值 key 在下一个散列函数 H;+1 下的散列地址,直到不再产生冲突为止。
   `这种方法的优点是不易产生“堆积”,缺点是计算量较大`。

5. 公共溢出区法

   按这种方法，散列表由两个一维数组组成。一个称为基本表，它实际上就是上面所说的散列表，另一个称为溢出表。插入首先在基本表上进行，假如发生冲突，则将同义词存入溢出表。这样，`基本表不可能发生“堆积”`。

### 6.4.3 散列表的基本操作算法

## 6.5 小结
