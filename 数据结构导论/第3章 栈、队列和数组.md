# 第 3 章 栈、队列和数组

## 3.1 栈

### 3.1.1 栈的基本概念

栈（Stack）是运算受限的线性表，这种线性表上的`插入和删除运算限定在表的某一端进行`。允许进行插入和删除的一端称为`栈顶`，另一端称为`栈底`。不含任何数据元素的栈称为`空栈`。处于栈顶位置的数据元素称为`栈顶元素`。

栈的`修改原则是后进先出（Last In First Out）`,因此，栈又称为后进先出线性表，简称后进先出表。栈的插入和删除运算分别称为`进栈（压栈）和出栈（弹栈）`。

栈的基本运算：

1. 初始化 InitStack(S)：构造一个空栈 S；
2. 判栈空 EmptyStack(S)：若栈 S 为空栈，则结果为 1，否则结果为 0；
3. 进栈 Push(S, x):将元素 x 插入栈 S 中，使 x 成为栈 S 的栈顶元素；
4. 出栈 Pop(S)：删除栈顶元素；
5. 取栈顶 GetTop(S)：返回栈顶元素；

### 3.1.2 栈的顺序实现

栈的顺序存储结构是用一组`连续的存储单元`依次存放栈中的每个元素，并用`始端`作为栈底。`栈的顺序实现称为顺序栈`。通常用`一个一维数组和一个记录栈顶位置的变量`来实现栈的顺序结构。

顺序栈的定义：

```c
const int maxsize = 6;  //顺序栈的容量
typedef struct seqstack
{
    DataType data[maxsize];    //存储栈中数据元素的数组
    int top;                   //标志栈顶位置的变量
} SeqStk;
```

1. 初始化 InitStack(S)

   ```c
   int InitStach(SeqStk *stk)
   {
    stk->top = 0;
    return 1;
   }
   ```

2. 判栈空 EmptyStack(S)：若栈 S 为空栈，则结果为 1，否则结果为 0；

   ```c
   int EmptyStack(SeqStk *stk)
   {
        if (stk->top == 0)
            return 1;
        else return 0;
   }
   ```

3. 进栈

   ```c
   int Push(SeqStk *stk, DataType x)
   {
       if (stk->top == maxsize - 1)
       {
           error("栈已满");
           return 0;
       } else {
            stk->top++;
            stk->data[stk->top] = x;
            return 1;
       }
   }
   ```

4. 出栈

   ```c
    int Pop(SeqStk *stk)
    {
        if (EmptyStack(stk)) {
            error("下溢（空栈）");
            return 0;
        } else {
            stk->top--;
            return 1;
        }
    }
   ```

5. 取出栈顶元素

   ```c
   DataType GetTop(SeqStk *stk)
   {
       if (EmptyStack(stk)) return NULLData;
       else
           return stk->data[stk->top];
   }
   ```

在某些应用中，为了节省空间，让两个数据元素类型一致的栈共享一维数组空间 data[max]，称为`双栈`，两个栈的栈底在数组两端，仅仅当两个栈的栈顶位置在中间相遇时才发生“上溢”。`双栈的数据结构`定义：

```c
const int max=40;   //栈容量
typedef struct Dbstack
{
    DataType data[max];
    int top1, top2;
} DdStk;
```

### 3.1.3 栈的链接实现

`栈的链接实现称为链栈`，链栈可以`用带头结点的单链表来实现`。由于每个结点空间都是动态分配产生，链栈不用预先考虑容量的大小。

```c
typedef struct node
{
    DataType data;
    struct node *next;
} LkStk;
```

1. 初始化

   ```c
    void InitStach(LkStk *LS)
    {
        LS = (LkStk *)malloc(sizeof(LkStk));    //定义一个指针变量 LS，用于引用动态分配的内存。
        LS->next = NULL;    //栈初始化时，生成一个结点，将该结点的next域设置为NULL
    }

    //代码分析
    LS = (LkStk *)malloc(sizeof(LkStk));
    malloc 是一个库函数，用于分配指定字节数的内存。
    sizeof(LkStk) 计算类型 LkStk 的大小（以字节为单位）
    malloc(sizeof(LkStk))：这部分动态分配了足够的内存来存储一个 LkStk 类型的对象。
    (LkStk *)：这是一个强制类型转换，将 malloc 返回的 void * 指针转换为 LkStk * 指针。
    LS = (LkStk *)malloc(sizeof(LkStk))：将分配的内存地址赋值给指针变量 LS
   ```

2. 判栈空

   ```c
    int EmptyStack(LkStk *LS)
    {
        if (LS->next == NULL)
            return 1;
        else
            return 0;
    }
   ```

3. 进栈

   ```c
    void Push (LkStk *LS, DataType x)
    {
        LkStk *temp;
        temp = (LkStk *)malloc(sizeof(LkStk)); //temp指向申请的新结点
        temp->data = x;
        temp->next = LS->next;
        LS->next = temp;
    }
   ```

4. 出栈 Pop(S)：删除栈顶元素；

   ```c
    int Pop(LkStk *LS)
    {
        LkStk *temp;
        if (!EmptyStack(LS))
        {
            temp = LS->next;
            LS->next = temp->next;
            free(temp); //释放原栈顶结点空间
            return 1;
        }
        else return 0;
    }
   ```

5. 取栈顶 GetTop(S)：返回栈顶元素

   ```c
    DataType GetTop(LkStk *LS)
    {
        if (!EmptyStack(LS))
            return LS->next->data;
        else return NULLData;
    }
   ```

### 3.1.4 栈的简单应用和递归

1. 栈的简单应用举例
2. 递归与栈

   以下是递归算法的一个简单例子：计算阶乘（factorial）。

   ```c
   #include <stdio.h>

   // 递归函数计算阶乘。函数的调用顺序是f(3),f(2),f(1),f(0)，而求出阶乘的顺序是0！1！2！3！,这个过程具有栈的后进先出特征。
   int factorial(int n) {
       // 基本情况：0的阶乘为1
       if (n == 0) {
           return 1;
       }
       // 递归调用：n的阶乘等于n乘以(n-1)的阶乘
       return n * factorial(n - 1);
   }

   int main() {
       int n = 5;
       printf("Factorial of %d is %d\n", n, factorial(n));
       return 0;
   }
   ```

   虽然递归是一种强大的算法设计技巧，但在实际应用中需要注意避免出现无限递归（导致栈溢出）以及过度消耗内存等问题。

## 3.2 队列

### 3.2.1 队列的基本概念

队列（Queue）是有限个同类型数据元素的线性序列，是一种`先进先出（First-In-First-Out，FIFO）的线性表`，队列类似于现实生活中排队的概念，最先加入队列的元素最先被移出。

队列的基本运算：

1. 队列初始化 InitQueue(Q)：设置一个空队列 Q；
2. 判队列空 EmptyQueue(Q)：若队列 Q 为空，则返回值为 1，否则返回值为 0；
3. 入队列 EnQueue(Q, x)：将数据元素 x 从队尾一端插入队列，使其成为队列的新尾元素。
4. 除队列 OutQueue(Q)：删除队列首元素；
5. 取队列首元素 GetHead(Q)：返回队列首元素的值。

### 3.2.2 队列的顺序实现

### 3.2.3 队列的链接实现

### 3.2.4 队列应用

## 3.3 数组

## 3.4 应用举例

## 3.5 小结
