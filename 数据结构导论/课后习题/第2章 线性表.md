# 第 2 章 线性表

## 1.填空题

1. 设 r 指向单链表的最后一个结点，要在最后一个结点之后插入 s 所指定的结点，需要执行的语句序列是`r->next=s`；r=s; r->next=NULL。

   要在单链表的最后一个节点之后插入一个新节点，需要执行以下语句序列：

   1. 将新节点的 `next` 指针指向 `NULL`，表示新节点为链表的最后一个节点。
   2. 将原链表最后一个节点的 `next` 指针指向新节点，使得新节点成为链表的最后一个节点。

   下面是具体的语句序列：

   ```c
   s->next = NULL; // 将新节点的 next 指针指向 NULL，表示新节点为链表的最后一个节点
   r->next = s;   // 将原链表最后一个节点的 next 指针指向新节点 s
   r = s;        // 更新 r 指针，使其指向新的最后一个节点 s
   ```

   这个语句序列假设变量 `r` 指向原链表的最后一个节点，变量 `s` 指向要插入的新节点。执行完这个语句序列后，链表中就插入了新节点，并且新节点成为了链表的最后一个节点。

2. 在单链表中，指针 p 所指的结点为最后一个结点的条件是`p->next==NULL`

   在单链表中，指针 `p` 所指的结点为最后一个结点的条件是 `p->next` 指向 `NULL`。这是因为在单链表中，每个结点的 `next` 指针都指向下一个结点，而最后一个结点没有下一个结点，因此其 `next` 指针指向 `NULL`。

   因此，当指针 `p` 所指的结点是最后一个结点时，其 `next` 指针应该为 `NULL`。这是判断 `p` 是否为最后一个结点的条件。

3. 在带头结点的单链表 L 中，第一个数据元素结点的指针为`L->next`

   在带头结点的单链表中，第一个数据元素结点的指针可以通过头结点的 `next` 指针来获得。头结点通常位于链表的起始位置，其 `next` 指针指向第一个数据元素结点。

   因此，第一个数据元素结点的指针可以表示为 `L->next`，其中 `L` 是指向头结点的指针。

4. 在双向循环链表中，在指针 p 所指结点前插入指针 s 所指的结点，需执行下列语句：  
   s->next=p; s->prior=p->prior; p->prior=s; ` `=s;

   在双向循环链表中，在指针 `p` 所指的结点前插入指针 `s` 所指的结点，需要执行以下语句序列：

   1. 将新节点 `s` 的 `next` 指针指向节点 `p`，即新节点 `s` 的下一个节点为节点 `p`。
   2. 将节点 `p` 前一个节点的 `next` 指针指向新节点 `s`，即节点 `p` 的前一个节点的下一个节点为新节点 `s`。
   3. 将新节点 `s` 的 `prev` 指针指向节点 `p` 前一个节点，即新节点 `s` 的前一个节点为节点 `p` 前一个节点。

   下面是具体的语句序列：

   ```c
   s->next = p;          // 将新节点 s 的 next 指针指向节点 p
   s->prev = p->prev;    // 将新节点 s 的 prev 指针指向节点 p 前一个节点
   p->prev->next = s;    // 将节点 p 前一个节点的 next 指针指向新节点 s
   p->prev = s;          // 将节点 p 的 prev 指针指向新节点 s
   ```

   这个语句序列假设变量 `p` 指向原链表中的某个节点，变量 `s` 指向要插入的新节点。执行完这个语句序列后，新节点 `s` 就被成功地插入到了节点 `p` 所指的结点之前。

5. 带头结点的双向循环链表 L 为空的条件是` `

   带头结点的双向循环链表为空的条件是头结点的 `next` 和 `prev` 指针都指向头结点自身。具体地说，即头结点的 `next` 指针指向头结点自身，同时头结点的 `prev` 指针也指向头结点自身。

   换句话说，如果链表为空，则头结点的 `next` 和 `prev` 指针都指向头结点自身，形成一个环形结构。这样可以方便地判断链表是否为空，同时也方便了链表的插入和删除操作。

## 2.应用题或解答题

1. 何时选用顺序表，何时选用链表作为线性表的存储结构？

   选择顺序表（数组）或链表作为线性表的存储结构取决于具体的应用需求和情况。以下是一些考虑因素：

   ### 选择顺序表的情况：

   1. **频繁随机访问**：如果需要频繁地通过索引随机访问元素，那么顺序表是更合适的选择，因为它具有连续的内存空间，可以通过索引高效地访问元素。
   2. **内存局部性**：顺序表具有良好的内存局部性，可以有效利用计算机的缓存机制，因此在处理大量数据时可能具有更好的性能。
   3. **节省存储空间**：顺序表通常比链表更节省存储空间，因为它不需要额外的指针来存储元素之间的关系。

   ### 选择链表的情况：

   1. **频繁插入和删除操作**：如果需要频繁地执行插入和删除操作，特别是在表的中间位置，链表是更合适的选择。由于链表的元素存储在不连续的内存空间中，插入和删除操作的时间复杂度通常为 O(1)。
   2. **动态内存管理**：链表可以动态地分配和释放内存，因此更适合在运行时动态增长或缩减的情况下使用。
   3. **对内存空间的使用不确定**：如果无法预先知道线性表的大小，或者需要经常动态调整大小，那么链表是更灵活的选择，因为它可以根据需要动态增长或缩减。

   总的来说，顺序表适用于需要频繁随机访问和节省存储空间的情况，而链表适用于需要频繁插入和删除以及动态内存管理的情况。在实际应用中，需要根据具体的需求和性能要求来选择合适的存储结构。

2. 论述以下概念：指针变量、头指针、头结点、首结点，并说明头指针变量和头结点的作用。

   在讨论这些概念之前，让我们首先了解链表的基本结构。链表是一种由一系列节点组成的数据结构，每个节点包含两部分：数据和指向下一个节点的指针。

   现在我们来论述以下概念：

   1. **指针变量**：指针变量是一种特殊类型的变量，它存储其他变量或数据的地址。指针变量允许直接访问或操作存储在内存中的数据。

   2. **头指针**：头指针是指向链表第一个节点的指针变量。它提供了访问链表的入口，并允许我们遍历整个链表。在带头结点的链表中，头指针指向头结点。

   3. **头结点**：头结点是位于链表起始位置的特殊节点，它不存储任何实际的数据。头结点的主要作用是为链表的操作提供统一的入口，使得链表的插入、删除等操作更加方便。头结点可以简化对链表的边界条件处理，并使得链表中的所有节点具有相同的结构。

   4. **首结点**：首结点是链表中的第一个包含数据的节点。在带头结点的链表中，首结点是头结点的后继节点，即头结点的 `next` 指针所指向的节点。

   头指针变量和头结点的作用：

   - **头指针变量**：头指针变量存储链表的起始位置，使得我们能够轻松地访问整个链表。它充当了整个链表的入口，使得我们可以在不影响链表中的任何数据的情况下对链表进行操作。

   - **头结点**：头结点是链表中的一个特殊节点，它不存储任何实际的数据，只是作为链表操作的入口。头结点的存在可以简化对链表的操作，特别是在处理边界情况时，如空链表或链表的头部插入等操作。头结点还可以使得链表中的所有节点都具有相同的结构，从而提高代码的一致性和可维护性。

   总之，头指针变量和头结点在带头结点的链表中都扮演着重要的角色，它们使得链表的操作更加方便和统一。

## 3.算法设计题
