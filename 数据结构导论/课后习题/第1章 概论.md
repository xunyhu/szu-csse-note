# 第 1 章 概论

## 填空题

1. 从数据结构的观点看，通常所说的“数据”应分为三个不同的层次，即`数据`、`数据元素`、`数据项`。
2. 数据项又称为`字段`或`域`，它是数据的不可分割的最小标识单位。
3. 根据数据元素之间关系的不同特性，通常有`集合`、`线性结构`、`树形结构`、`图结构`四类基本逻辑结构，他们反映了四类基本的数据组织形式。
4. 在一般情况下，一个算法的时间复杂度是`算法输入规模`的函数。  
   在一般情况下，一个算法的时间复杂度通常是输入规模 n 的一个函数。这表示算法执行所需的时间与输入规模 n 的大小相关，可以用一个函数来描述算法执行时间随着输入规模增长的趋势
5. 常见算法时间复杂度的阶数有常数阶`O(1)`、对数阶`O(log n)`、线性阶`O(n)`、平方阶`O(n^2)`、和指数阶`O(2^n)`。通常认为，具有指数阶量级的算法是`实际不可计算`的，而量级低于平方阶的算法是`高效`的。

## 应用题或解答题

1. 什么是数据、数据元素以及数据项？它们有何区别？

   数据：所有被计算机存储、处理的对象。

   数据元素：数据的基本单位，在程序中作为一个整体而加以考虑和处理。

   数据项：数据元素由数据项组成。在数据库中数据项又称为字段或域。它是数据的不可分割的最小标识单位。

2. 什么是数据的逻辑结构？什么是数据的存储结构？

   数据的逻辑结构：是指数据元素之间的逻辑关系。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。

   数据的存储结构: 存储结构是指数据结构在计算机中的映像，也称物理结构。它包括数据元素的表示和关系的表示，是逻辑结构用计算机语言的实现。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。

3. 数据逻辑结构与存储结构有什么关系？

   数据的逻辑结构描述了数据元素之间的逻辑关系，而数据的存储结构则描述了数据在计算机内存或磁盘等存储介质上的组织方式。数据的逻辑结构与存储结构之间有着密切的关系，二者相互影响，具体表现如下：

   **逻辑结构决定存储结构：** 不同的逻辑结构需要采用不同的存储结构来实现。例如，线性表的逻辑结构可以采用顺序存储结构或链式存储结构来实现。

   **存储结构影响逻辑结构的操作效率：** 不同的存储结构会影响到对数据的操作效率。例如，对于树形结构，如果采用数组来存储节点，可能会增加节点的查找和插入操作的复杂度。

   **逻辑结构与存储结构的转换：** 在实际应用中，可能需要将数据从一种逻辑结构转换为另一种逻辑结构，这通常涉及到对存储结构的调整。例如，将一个数组转换为链表，需要重新分配内存并调整指针指向。

   **存储结构影响数据的访问方式：** 不同的存储结构会影响到数据的访问方式。例如，对于数组，可以通过下标直接访问元素；而对于链表，则需要通过遍历指针来访问元素。

   总的来说，数据的逻辑结构和存储结构是密不可分的，二者相互影响，共同决定了数据的组织方式和操作效率。在设计和实现数据结构时，需要综合考虑逻辑结构和存储结构之间的关系，以及它们对数据操作效率的影响。

4. 用计算机实现例 1-2 地图的着色问题，需要经过哪些主要步骤？每个步骤的主要工作是什么？
   - C/230420.c
   - [地图染色算法](https://blog.csdn.net/tengweitw/article/details/17641017)

## 算法设计题

```c
//1. 设计算法在整型数组 A[n]中查找值为 K 的元素，若找到，则输出其位置 i(0<=i<=n-1)，否则输出-1 作为标志，并分析算法的时间复杂度。
#include <stdio.h>

int findElement(int A[], int n, int K) {
   for (int i = 0; i < n; i++) {
      if (A[i] == K) {
            return i;  // 找到元素，返回位置
      }
   }
   return -1;  // 未找到元素，返回-1
}

int main() {
   int A[] = {1, 2, 3, 4, 5};
   int n = 5;
   int K = 3;
   int result = findElement(A, n, K);
   if (result != -1) {
      printf("Element found at index: %d\n", result);
   } else {
      printf("Element not found\n");
   }
   return 0;
}
//该算法的时间复杂度为 O(n)，其中 n 是数组 A 的大小。因为算法需要遍历整个数组来查找元素，最坏情况下需要遍历整个数组才能确定元素是否存在，所以时间复杂度为 O(n)。


/**
 * 2. 写出计算方阵 A[n][n]与 B[n][n]乘积 C[n][n]的算法，分析算法的时间复杂度。
 */
#include <stdio.h>

#define N 3  // 定义方阵的大小为 3，你可以根据需要修改为其他值

void matrixMultiplication(int A[][N], int B[][N], int C[][N]) {
   for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
            C[i][j] = 0;  // 初始化 C[i][j] 为 0
            for (int k = 0; k < N; k++) {
               C[i][j] += A[i][k] * B[k][j];  // 计算 C[i][j] 的值
            }
      }
   }
}

int main()
{
   int A[N][N] = \{\{1, 2, 3}, {4, 5, 6}, {7, 8, 9}/}/;
   int B[N][N] = \{\{9, 8, 7}, {6, 5, 4}, {3, 2, 1}/}/;
   int C[N][N];

   matrixMultiplication(A, B, C);

   // 输出乘积矩阵 C
   printf("Matrix C:\n");
   for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
            printf("%d ", C[i][j]);
      }
      printf("\n");
   }

   return 0;
}
```
