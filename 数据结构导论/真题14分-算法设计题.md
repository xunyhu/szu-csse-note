# 算法设计题

算法设计题（7\*2，14 分）

## 第 1 章 概论

1. 编制函数求 1!+2!+…+n!。

```c
int factorial(int n)
{
    int i, j, temp, s;
    s = 0;
    for (int i=1; i<=n; i++) {
        temp = i;
        for (int j=1; j<=i; j++) {
            temp = temp * j;
            s = temp + s;
        }
    }
    return s;
}
```

## 第 2 章 线性表

1. 在单链表存储结构中，线性表的表长等于单链表中数据元素的结点个数，即除了头结点以外的结点的个数，通常通过头指针 head 来访问一个单链表。已知单链表结构如下：

   ```c
   typedef struct node
   {
       DataType data;
       struct node *next;
   }Node, *LinkList;
   ```

   设计求表长的算法，要求算法返回表长。

   ```c
   int LengthLinkList(LinkList head)
   {
       Node *p=head;
       int cnt=0;
       while(p->next!=NULL)
       {
           p=p->next;
           cnt++;
       }
       return cnt;
   }
   ```

2. 写出一个将线性表的顺序表存储方式（数组 a 表长为 n）改成单链表存储方式（其头结点由头指针 head 指向）的算法。设函数头为：Node \* CreateLinkedList(DataType a[],int n)

   ```c
   Node * CreateLinkedList(DataType a[],int n) {
       head=(Node _ )malloc(sizeof(Node));
       head->next=NULL;
       for(i=n;i>0;i--) {
           p=(Node _ )malloc(sizeof(Node));
           p->data=a[i-1];
           p->next=head->next;
           head->next=p;
       }
       return head;
   }
   ```

3. 假定线性表的数据元素的类型为 DataType，顺序表的结构定义如下:

   ```c
   const int Maxsize=100;
   typedef struct
   {
    DataType data[Maxsize];
    int length;
   }SeqList;
   SeqList L;
   ```

   设计算法实现顺序表的插入运算 InsertSeqlist(Seqlist L,DataType x,int i)。该算法是指在顺序表的第（1≤i≤n+1）个元素之前，插入一个新元素 x。使长度为 n 的线性表<span>(a<sub>1</sub>，a<sub>2</sub>，…，a<sub>i-1</sub>，a<sub>i</sub>，…，a<sub>n</sub>)变为长度为 n+1 的线性表(a<sub>1</sub>，a<sub>2</sub>，…，a<sub>i-1</sub>，x，a<sub>i</sub>，…，a<sub>n</sub>)。</span>

   ```c
   void InsertSeqlist(SeqList L,DataType x,int i)
   {
      if(L.length==Maxsize)
        exit(“表已满”);
      if(i<1||i>L.length+1)
        exit(“位置错”);
      for(j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
      L.data[i-1]=x;
      L.length++;
   }
   ```

4. 假设单链表的类型定义如下

   ```c
   typedef struct node
   {
    DataType data;
    struct node *next;
   }Node, *LinkList;
   ```

   设计算法 InitiateLinkList()实现单链表的初始化。

   ```c
    LinkList InitiateLinkList()
    {
        LinkList head;
        head = (Node)malloc(sizeof(Node));
        head->next=NULL;
        return head;
    }
   ```

5. 某电商有关手机的库存信息，按其价格从低到高存储在一个带有头结点的单循环链表中，链表中的结点由品牌型号（nametype）、价格（price）、数量（quantity）和指针（next）四个域组成。现新到 m 台、价格为 c、品牌型号为 x 的新款手机需入库，写出相应的存储结构和实现该要求的算法。

   ```c
    // 存储结构
   typedef struct node {
        char *nametype;
        int price;
        int quantity;
        struct node *next;
   } Node, *LinkedList;
   // 实现算法
   void add(LinkedList head, char *x, int m, float c) {
    Node *newPhone = (Node *)malloc(sizeof(Node));
    newPhone ->nametype = x;
    newPhone ->price = c;
    newPhone ->quantity = m;
    newPhone ->next = NULL;
    Node *q = head;
    Node *p = head->next;
    while (p != head && p->price < c) {
        q = q->next;
        p = p->next;
    }
    newPhone ->next = p;
    q->next = newPhone ;
    return;
   }
   ```
