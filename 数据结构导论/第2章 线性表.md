## 2.1 线性表的基本概念

线性表（linear list）是数据结构的一种，一个线性表是 n 个具有相同特性的数据元素的有限序列，数据元素又称为结点。  
线性表是一种常见的数据结构，它是由 n(n>=0) 个数据元素（元素个数为零时称为空表）组成的有限序列。线性表中的数据元素具有相同的数据类型，且相邻元素之间存在顺序关系。

以下是线性表的一些基本概念：

1. **元素：** 线性表中的每个数据项称为元素。元素可以是任意数据类型，如整数、字符、结构体等。

2. **位置：** 线性表中每个元素所处的位置称为位置。位置通常用整数来表示，从 1 开始递增。

3. **长度：** 线性表中元素的个数称为长度。长度可以为零，表示空表。

4. **顺序存储：** 线性表中的元素按照其逻辑顺序依次存放在一片连续的存储空间中，这种存储方式称为顺序存储结构。

5. **链式存储：** 线性表中的元素通过指针、引用或地址等相互连接起来，每个元素包含了指向下一个元素的指针，这种存储方式称为链式存储结构。

6. **查找：** 在线性表中查找指定位置或指定元素。

7. **插入：** 在线性表的指定位置插入一个新元素。

8. **删除：** 在线性表中删除指定位置的元素。

线性表是最简单、最基础的数据结构之一，常用于表示一维数据结构，如数组和链表等。它提供了基本的数据操作方法，如查找、插入和删除等，是其他复杂数据结构的基础。

线性表的特征：

    结点具有一对一的关系，如果结点数不为零，则除起始结点没有直接前驱外，其他每个结点有且仅有一个直接前驱；除终端结点没有直接后继外，其他每个结点有且仅有一个直接后继。

线性表的基本运算：

    1.初始化；2.求表长；3.读表元素；4.定位；5.插入；6.删除。

以下是使用 C 语言实现线性表的基本运算：

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100  // 定义线性表的最大长度

// 定义线性表结构体
typedef struct {
    int data[MAX_SIZE];  // 数据数组
    int length;          // 线性表长度
} List;

// 初始化线性表
void initList(List *list) {
    list->length = 0;  // 将线性表长度初始化为0
}

// 获取线性表指定位置的元素
int getElement(List *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    return list->data[index];
}

// 在线性表指定位置插入元素
void insertElement(List *list, int index, int element) {
    if (list->length == MAX_SIZE) {
        printf("List is full\n");
        exit(1);
    }
    if (index < 0 || index > list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    // 将插入位置后的元素后移一位
    for (int i = list->length; i > index; i--) {
        list->data[i] = list->data[i - 1];
    }
    // 在插入位置处插入新元素
    list->data[index] = element;
    // 线性表长度加1
    list->length++;
}

// 删除线性表指定位置的元素
void deleteElement(List *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    // 将删除位置后的元素前移一位
    for (int i = index; i < list->length - 1; i++) {
        list->data[i] = list->data[i + 1];
    }
    // 线性表长度减1
    list->length--;
}

int main() {
    List list;
    initList(&list);  // 初始化线性表

    // 在线性表末尾插入元素
    insertElement(&list, 0, 1);
    insertElement(&list, 1, 2);
    insertElement(&list, 2, 3);

    // 输出线性表中的元素
    printf("Elements in the list: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", list.data[i]);
    }
    printf("\n");

    // 删除线性表中的第二个元素
    deleteElement(&list, 1);

    // 输出删除后的线性表中的元素
    printf("Elements in the list after deletion: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", list.data[i]);
    }
    printf("\n");

    return 0;
}
这段代码实现了线性表的初始化、获取元素、插入元素和删除元素等基本运算。你可以根据需要进行扩展和修改。

```

#### 线性表的存储结构

线性表的存储结构主要有两种形式：顺序存储结构和链式存储结构。

1. **顺序存储结构：**

   - 顺序存储结构使用一段连续的存储空间来存储线性表的元素。
   - 元素在内存中按照其逻辑顺序依次存放，元素之间的物理地址是连续的。
   - 顺序存储结构的优点是随机访问速度快，适用于元素的查找操作。
   - 缺点是插入和删除操作可能涉及大量元素的移动，效率较低。
   - 典型的顺序存储结构包括使用数组实现的顺序表。

2. **链式存储结构：**
   - 链式存储结构使用一组任意的存储空间来存储线性表的元素，元素之间通过指针或引用相互连接起来。
   - 每个元素包含一个数据域和一个指针域，指针指向下一个元素。
   - 链式存储结构的优点是插入和删除操作方便，不需要移动大量元素。
   - 缺点是访问速度相对较慢，因为需要通过指针逐个访问元素。
   - 典型的链式存储结构包括单链表、双链表和循环链表等。

选择合适的存储结构取决于具体的应用场景和操作需求。如果需要频繁进行查找操作，可以选择顺序存储结构；如果需要频繁进行插入和删除操作，可以选择链式存储结构。

[线性表的基本概念](https://www.huweihuang.com/data-structure-notes/list/list-concept.html)

## 2.2 线性表的顺序存储

1. 线性表顺序存储的类型定义

   线性表的顺序存储结构是使用一段连续的存储空间来存储线性表的元素，通常通过`数组`来实现。在顺序存储结构中，线性表中的元素按照其逻辑顺序依次存放在数组中，元素之间的物理地址是连续的。

2. 线性表的基本运算在顺序表上的实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100  // 定义线性表的最大长度

// 定义顺序表结构体
typedef struct {
    int data[MAX_SIZE];  // 数据数组
    int length;          // 线性表长度
} SeqList;

// 初始化顺序表
void initList(SeqList *list) {
    list->length = 0;
}

// 获取顺序表指定位置的元素
int getElement(SeqList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    return list->data[index];
}

// 在顺序表的指定位置插入元素
void insertElement(SeqList *list, int index, int element) {
    if (list->length == MAX_SIZE) {
        printf("List is full\n");
        exit(1);
    }
    if (index < 0 || index > list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    // 将插入位置及其后面的元素后移一位
    for (int i = list->length; i > index; i--) {
        list->data[i] = list->data[i - 1];
    }
    // 在插入位置处插入新元素
    list->data[index] = element;
    // 线性表长度加1
    list->length++;
}

// 删除顺序表指定位置的元素
void deleteElement(SeqList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    // 将删除位置后的元素前移一位
    for (int i = index; i < list->length - 1; i++) {
        list->data[i] = list->data[i + 1];
    }
    // 线性表长度减1
    list->length--;
}

// 在顺序表中查找指定元素的位置
int locateElement(SeqList *list, int element) {
    for (int i = 0; i < list->length; i++) {
        if (list->data[i] == element) {
            return i;  // 找到元素，返回位置
        }
    }
    return -1;  // 未找到元素，返回-1
}

int main() {
    SeqList list;
    initList(&list);  // 初始化顺序表

    // 在顺序表末尾插入元素
    insertElement(&list, 0, 1);
    insertElement(&list, 1, 2);
    insertElement(&list, 2, 3);

    // 输出线性表中的元素
    printf("Elements in the list: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", list.data[i]);
    }
    printf("\n");

    // 删除线性表中的第二个元素
    deleteElement(&list, 1);

    // 输出删除后的线性表中的元素
    printf("Elements in the list after deletion: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", list.data[i]);
    }
    printf("\n");

    // 查找元素2在顺序表中的位置
    int index = locateElement(&list, 2);
    if (index != -1) {
        printf("Element 2 is found at index: %d\n", index);
    } else {
        printf("Element 2 is not found\n");
    }

    return 0;
}

```

## 2.3 线性表的链接存储

1. 单链表的类型定义

单链表是一种常见的链式存储结构，由一系列节点组成，`每个节点包含一个数据域和一个指针域，指向下一个节点`。下面是单链表的类型定义：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义单链表节点结构体
typedef struct ListNode {
    int data;             // 数据域，存储节点的数据
    struct ListNode *next; // 指针域，指向下一个节点的指针
} ListNode;

// 定义单链表结构体
typedef struct {
    ListNode *head;  // 头指针，指向链表的第一个节点
    int length;      // 链表长度
} LinkedList;

```

2. 线性表的基本运算在单链表上的实现

```c
#include <stdio.h>
#include <stdlib.h>

// 定义单链表节点结构体
typedef struct ListNode {
    int data;             // 数据域，存储节点的数据
    struct ListNode *next; // 指针域，指向下一个节点的指针
} ListNode;

// 定义单链表结构体
typedef struct {
    ListNode *head;  // 头指针，指向链表的第一个节点
    int length;      // 链表长度
} LinkedList;

// 初始化单链表
void initLinkedList(LinkedList *list) {
    list->head = NULL;  // 头指针为空，表示空链表
    list->length = 0;   // 链表长度为0
}

// 在单链表的指定位置插入元素
void insertElement(LinkedList *list, int index, int element) {
    if (index < 0 || index > list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    // 创建新节点
    ListNode *newNode = (ListNode *)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = element;
    newNode->next = NULL;
    // 在链表头部插入新节点
    if (index == 0) {
        newNode->next = list->head;
        list->head = newNode;
    } else {
        ListNode *current = list->head;
        // 找到插入位置的前一个节点
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        // 插入新节点
        newNode->next = current->next;
        current->next = newNode;
    }
    // 链表长度加1
    list->length++;
}

// 删除单链表指定位置的元素
void deleteElement(LinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *temp;
    // 删除链表头部节点
    if (index == 0) {
        temp = list->head;
        list->head = list->head->next;
    } else {
        ListNode *current = list->head;
        // 找到删除位置的前一个节点
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        temp = current->next;
        current->next = temp->next;
    }
    // 释放被删除节点的内存
    free(temp);
    // 链表长度减1
    list->length--;
}

// 获取单链表指定位置的元素
int getElement(LinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *current = list->head;
    // 找到指定位置的节点
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

int main() {
    LinkedList list;
    initLinkedList(&list);  // 初始化单链表

    // 在单链表末尾插入元素
    insertElement(&list, 0, 1);
    insertElement(&list, 1, 2);
    insertElement(&list, 2, 3);

    // 输出单链表中的元素
    printf("Elements in the list: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    // 删除单链表中的第二个元素
    deleteElement(&list, 1);

    // 输出删除后的单链表中的元素
    printf("Elements in the list after deletion: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    return 0;
}

```

## 2.4 其他运算在单链表上的实现

## 2.5 其他链表

1. 循环链表

循环链表是一种特殊的链式存储结构，在单链表的基础上，将尾节点的指针指向头节点，形成一个环形结构。循环链表可以通过任意节点进行遍历，而不必从头节点开始。

以下是循环链表的类型定义和基本操作的示例代码：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义循环链表节点结构体
typedef struct ListNode {
    int data;             // 数据域，存储节点的数据
    struct ListNode *next; // 指针域，指向下一个节点的指针
} ListNode;

// 定义循环链表结构体
typedef struct {
    ListNode *head;  // 头指针，指向循环链表的第一个节点
    int length;      // 链表长度
} CircularLinkedList;

// 初始化循环链表
void initCircularLinkedList(CircularLinkedList *list) {
    list->head = NULL;  // 头指针为空，表示空循环链表
    list->length = 0;   // 链表长度为0
}

// 在循环链表的末尾插入元素
void insertElement(CircularLinkedList *list, int element) {
    // 创建新节点
    ListNode *newNode = (ListNode *)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = element;
    newNode->next = NULL;
    // 如果循环链表为空，则新节点即为头节点
    if (list->head == NULL) {
        list->head = newNode;
        newNode->next = newNode;  // 将尾节点的指针指向头节点，形成循环
    } else {
        ListNode *current = list->head;
        // 找到尾节点
        while (current->next != list->head) {
            current = current->next;
        }
        // 将新节点插入到尾节点之后
        current->next = newNode;
        newNode->next = list->head;  // 将新节点的指针指向头节点，形成循环
    }
    // 链表长度加1
    list->length++;
}

// 删除循环链表指定位置的元素
void deleteElement(CircularLinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *temp;
    // 删除头节点
    if (index == 0) {
        temp = list->head;
        // 找到尾节点
        ListNode *current = list->head;
        while (current->next != list->head) {
            current = current->next;
        }
        // 将尾节点的指针指向第二个节点
        current->next = list->head->next;
        // 更新头指针
        list->head = list->head->next;
    } else {
        ListNode *current = list->head;
        // 找到删除位置的前一个节点
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        temp = current->next;
        current->next = temp->next;
    }
    // 释放被删除节点的内存
    free(temp);
    // 链表长度减1
    list->length--;
}

// 获取循环链表指定位置的元素
int getElement(CircularLinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *current = list->head;
    // 找到指定位置的节点
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

int main() {
    CircularLinkedList list;
    initCircularLinkedList(&list);  // 初始化循环链表

    // 在循环链表末尾插入元素
    insertElement(&list, 1);
    insertElement(&list, 2);
    insertElement(&list, 3);

    // 输出循环链表中的元素
    printf("Elements in the list: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    // 删除循环链表中的第二个元素
    deleteElement(&list, 1);

    // 输出删除后的循环链表中的元素
    printf("Elements in the list after deletion: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    return 0;
}

```

2. 双向循环链表

双向循环链表是一种特殊的链式存储结构，每个节点包含两个指针域，分别指向前一个节点和后一个节点，形成一个环形结构。双向循环链表可以通过任意节点进行双向遍历，而不必从头节点开始或从尾节点结束。

以下是双向循环链表的类型定义和基本操作的示例代码：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义双向循环链表节点结构体
typedef struct ListNode {
    int data;                // 数据域，存储节点的数据
    struct ListNode *prev;  // 指向前一个节点的指针
    struct ListNode *next;  // 指向后一个节点的指针
} ListNode;

// 定义双向循环链表结构体
typedef struct {
    ListNode *head;  // 头指针，指向双向循环链表的第一个节点
    int length;      // 链表长度
} DoublyCircularLinkedList;

// 初始化双向循环链表
void initDoublyCircularLinkedList(DoublyCircularLinkedList *list) {
    list->head = NULL;  // 头指针为空，表示空双向循环链表
    list->length = 0;   // 链表长度为0
}

// 在双向循环链表的末尾插入元素
void insertElement(DoublyCircularLinkedList *list, int element) {
    // 创建新节点
    ListNode *newNode = (ListNode *)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = element;
    newNode->prev = NULL;
    newNode->next = NULL;
    // 如果双向循环链表为空，则新节点即为头节点
    if (list->head == NULL) {
        list->head = newNode;
        newNode->prev = newNode;
        newNode->next = newNode;
    } else {
        ListNode *tail = list->head->prev;  // 尾节点
        // 将新节点插入到尾节点之后
        tail->next = newNode;
        newNode->prev = tail;
        newNode->next = list->head;
        list->head->prev = newNode;
    }
    // 链表长度加1
    list->length++;
}

// 删除双向循环链表指定位置的元素
void deleteElement(DoublyCircularLinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *temp;
    // 删除头节点
    if (index == 0) {
        temp = list->head;
        // 如果链表只有一个节点，则头指针置为空
        if (list->length == 1) {
            list->head = NULL;
        } else {
            ListNode *tail = list->head->prev;  // 尾节点
            list->head = list->head->next;       // 更新头指针
            tail->next = list->head;
            list->head->prev = tail;
        }
    } else {
        ListNode *current = list->head;
        // 找到删除位置的节点
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        temp = current;
        // 删除节点
        current->prev->next = current->next;
        current->next->prev = current->prev;
    }
    // 释放被删除节点的内存
    free(temp);
    // 链表长度减1
    list->length--;
}

// 获取双向循环链表指定位置的元素
int getElement(DoublyCircularLinkedList *list, int index) {
    if (index < 0 || index >= list->length) {
        printf("Index out of range\n");
        exit(1);
    }
    ListNode *current = list->head;
    // 找到指定位置的节点
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

int main() {
    DoublyCircularLinkedList list;
    initDoublyCircularLinkedList(&list);  // 初始化双向循环链表

    // 在双向循环链表末尾插入元素
    insertElement(&list, 1);
    insertElement(&list, 2);
    insertElement(&list, 3);

    // 输出双向循环链表中的元素
    printf("Elements in the list: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    // 删除双向循环链表中的第二个元素
    deleteElement(&list, 1);

    // 输出删除后的双向循环链表中的元素
    printf("Elements in the list after deletion: ");
    for (int i = 0; i < list.length; i++) {
        printf("%d ", getElement(&list, i));
    }
    printf("\n");

    return 0;
}

```

## 2.6 顺序实现与链接实现的比较

顺序实现和链式实现是常见的数据结构实现方式，它们各自具有一些优缺点，适用于不同的场景。下面是它们的比较：

1. **存储方式**：

   - **顺序实现**：使用数组等连续的存储空间存储数据，元素在内存中的地址是连续的。
   - **链式实现**：使用指针相连的节点来存储数据，每个节点包含数据和指向下一个节点的指针，元素在内存中的地址不一定是连续的。

2. **插入和删除操作**：

   - **顺序实现**：插入和删除操作可能需要移动大量元素，特别是在中间或开头插入或删除元素时，效率较低。
   - **链式实现**：插入和删除操作相对方便，只需修改指针指向，不需要移动大量元素，效率较高。

3. **访问操作**：

   - **顺序实现**：随机访问速度快，通过下标即可直接访问元素。
   - **链式实现**：访问速度相对较慢，需要从头节点开始逐个遍历或根据指针跳转到指定位置。

4. **内存管理**：

   - **顺序实现**：需要预先分配一定大小的存储空间，大小固定，可能存在空间浪费或溢出的风险。
   - **链式实现**：动态分配内存，可以根据需要灵活调整存储空间，不存在固定大小的限制。

5. **空间复杂度**：

   - **顺序实现**：空间复杂度较高，因为需要预先分配固定大小的存储空间。
   - **链式实现**：空间复杂度较低，只需要为实际存储的元素分配内存空间。

6. **适用场景**：
   - **顺序实现**：适用于元素访问频繁，但插入和删除操作较少的场景，如需要随机访问的情况。
   - **链式实现**：适用于插入和删除操作频繁，但元素访问较少的场景，如需要频繁更新的情况。

综上所述，顺序实现和链式实现各有优劣，选择合适的实现方式取决于具体的应用场景和操作需求。

## 2.7 小结

- 本章主要介绍线性表的基本概念、基本运算、线性表的顺序存储结构及基本运算的实现、线性表的链式存储结构及基本运算的实现。

## 思考与练习

### 1.填空题

1. 设 r 指向单链表的最后一个结点，要在最后一个结点之后插入 s 所指定的结点，需要执行的语句序列是` `；r=s; r->next=NULL。
2. 在单链表中，指针 p 所指的结点为最后一个结点的条件是` `
3. 在带头结点的单链表 L 中，第一个数据元素结点的指针为` `

### 2.应用题或解答题

1. 何时选用顺序表，何时选用链表作为线性表的存储结构？
2. 论述以下概念：指针变量、头指针、头结点、首结点，并说明头指针变量和头结点的作用。

### 3.算法设计题

1. 设线性表存放在数组 A[arrsize]的前 elenum 个分量中，且递增有序。试写一算法，将 x 插入到线性表的适当位置上，以保持线性表的元素仍然是递增有序的，并分析算法的时间复杂度。
2. 设带头结点的单链表的结点结构如下：
   ```c
   struct node {
     DataType data;
     struct node *next;
   } Node, *LinkList;
   ```
   试编写一个函数 int count(LinkList head, DataType x)统计单链表中数据域为 x 的结点个数。
3. 试编写在不带头结点的单链表上实现线性表基本运算 LENGTH(L)的算法。
4. 假设有两个按元素值递增有序排列的且带头结点的单链表 A 和表 B，请编写算法将表 A 和表 B 合并成一个按元素值递减有序排列的单链表 C，并要求利用原表(即表 A 和表 B)的结点空间存放表 C。
5. 写出判断带头结点的单链表 L 的元素值是否是递增的算法。
